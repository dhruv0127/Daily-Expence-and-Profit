!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){"use strict";t=t?t._modules:{};function e(t,e,a,r){t.hasOwnProperty(e)||(t[e]=r.apply(null,a),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:e,module:t[e]}})))}e(t,"Extensions/MarkerClusters.js",[t["Core/Animation/AnimationUtilities.js"],t["Core/Chart/Chart.js"],t["Core/Defaults.js"],t["Core/Series/Point.js"],t["Core/Series/Series.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Renderer/SVG/SVGRenderer.js"],t["Core/Utilities.js"],t["Core/Axis/Axis.js"]],function(t,e,a,r,i,o,n,s,l){function L(t,e){var a=t.chart,r=t.xAxis,t=t.yAxis;return a.mapView?a.mapView.pixelsToProjectedUnits(e):{x:r?r.toValue(e.x):0,y:t?t.toValue(e.y):0}}function D(t,e){var a=t.chart,r=t.xAxis,t=t.yAxis;return a.mapView?a.mapView.projectedUnitsToPixels(e):{x:r?r.toPixels(e.x):0,y:t?t.toPixels(e.y):0}}var m=t.animObject,t=a.defaultOptions,a=o.seriesTypes,p=n.prototype.symbols,k=s.addEvent,E=s.defined,S=s.error,b=s.isArray,A=s.isFunction,v=s.isObject,M=s.isNumber,X=s.merge,Y=s.objectEach,P=s.relativeLength,g=s.syncTimeout,o=a.scatter,z=i.prototype.generatePoints,u=[],d=0,w={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}};(t.plotOptions||{}).series=X((t.plotOptions||{}).series,{cluster:w,tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}});function T(t){for(var e=t.length,a=0,r=0,i=0;i<e;i++)a+=t[i].x,r+=t[i].y;return{x:a/e,y:r/e}}function h(t,e){var a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function c(t,e,a){t.attr({opacity:e}).animate({opacity:1},a)}function x(t,e,a,r,i){t.point&&(r&&t.point.graphic&&(t.point.graphic.show(),c(t.point.graphic,e,a)),i&&t.point.dataLabel&&(t.point.dataLabel.show(),c(t.point.dataLabel,e,a)))}function y(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function C(t,e,a,r){x(t,r,a,!0,!0),e.forEach(function(t){t.point&&t.point.destroy&&t.point.destroy()})}function O(){return Math.random().toString(36).substring(2,7)+"-"+d++}p.cluster=function(t,e,a,r){var a=a/2,r=r/2,i=p.arc(t+a,e+r,a-4,r-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),o=p.arc(t+a,e+r,a-3,r-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a-2,open:!1});return p.arc(t+a,e+r,a-1,r-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a,open:!1}).concat(o,i)},o.prototype.animateClusterPoint=function(t){var e,a,r=this.chart,i=r.mapView,o=this.options.cluster,n=m((o||{}).animation),o=n.duration||500,s=(this.markerClusterInfo||{}).pointsState,l=(s||{}).newState,p=(s||{}).oldState,u=[],d=0,h=0,c=!1,f=!1;p&&l&&(a=l[t.stateId],s=D(this,a),d=s.x-(i?0:r.plotLeft),h=s.y-(i?0:r.plotTop),1===a.parentsId.length?(s=(l||{})[t.stateId].parentsId[0],e=p[s],a.point&&a.point.graphic&&e&&e.point&&e.point.plotX&&e.point.plotY&&e.point.plotX!==a.point.plotX&&e.point.plotY!==a.point.plotY&&(i=a.point.graphic.getBBox(),r=a.point.graphic&&a.point.graphic.isImg?0:i.width/2,a.point.graphic.attr({x:e.point.plotX-r,y:e.point.plotY-r}),a.point.graphic.animate({x:d-(a.point.graphic.radius||0),y:h-(a.point.graphic.radius||0)},n,function(){f=!0,e.point&&e.point.destroy&&e.point.destroy()}),a.point.dataLabel&&a.point.dataLabel.alignAttr&&e.point.dataLabel&&e.point.dataLabel.alignAttr&&(a.point.dataLabel.attr({x:e.point.dataLabel.alignAttr.x,y:e.point.dataLabel.alignAttr.y}),a.point.dataLabel.animate({x:a.point.dataLabel.alignAttr.x,y:a.point.dataLabel.alignAttr.y},n)))):0===a.parentsId.length?(y(a,!0,!0),g(function(){x(a,.1,n,!0,!0)},o/2)):(y(a,!0,!0),a.parentsId.forEach(function(t){p&&p[t]&&(e=p[t],u.push(e),e.point&&e.point.graphic&&(c=!0,e.point.graphic.show(),e.point.graphic.animate({x:d-(e.point.graphic.radius||0),y:h-(e.point.graphic.radius||0),opacity:.4},n,function(){f=!0,C(a,u,n,.7)}),e.point.dataLabel&&-9999!==e.point.dataLabel.y&&a.point&&a.point.dataLabel&&a.point.dataLabel.alignAttr&&(e.point.dataLabel.show(),e.point.dataLabel.animate({x:a.point.dataLabel.alignAttr.x,y:a.point.dataLabel.alignAttr.y,opacity:.4},n))))}),g(function(){f||C(a,u,n,.85)},o),c||g(function(){C(a,u,n,.1)},o/2)))},o.prototype.getGridOffset=function(){var t=this,e=t.chart,a=t.xAxis,r=t.yAxis;return{plotLeft:a&&t.dataMinX&&t.dataMaxX?a.reversed?a.toPixels(t.dataMaxX):a.toPixels(t.dataMinX):e.plotLeft,plotTop:r&&t.dataMinY&&t.dataMaxY?r.reversed?r.toPixels(t.dataMinY):r.toPixels(t.dataMaxY):e.plotTop}},o.prototype.getScaledGridSize=function(t){var e=this,a=e.xAxis,r=this.chart.mapView,t=t.processedGridSize||w.layoutAlgorithm.gridSize,i=!0,o=1,n=1;e.gridValueSize||(e.gridValueSize=r?t/r.getScale():Math.abs(a.toValue(t)-a.toValue(0)));for(var s=+(t/(r?e.gridValueSize*r.getScale():a.toPixels(e.gridValueSize)-a.toPixels(0))).toFixed(14);i&&1!=s;){var l=Math.pow(2,o);.75<s&&s<1.25?i=!1:1/l<=s&&s<1/l*2?(i=!1,n=l):s<=l&&l/2<s&&(i=!1,n=1/l),o++}return t/n/s},o.prototype.getRealExtremes=function(){var t=this.chart,e=t.mapView?0:t.plotLeft,a=t.mapView?0:t.plotTop,a=L(this,{x:e,y:a}),e=L(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=a.x,r=e.x,a=a.y,e=e.y;return{minX:Math.min(t,r),maxX:Math.max(t,r),minY:Math.min(a,e),maxY:Math.max(a,e)}},o.prototype.onDrillToCluster=function(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){var e,a,r,i,o,n=t.point||t.target,s=n.series,l=n.series.xAxis,p=n.series.yAxis,u=n.series.chart,d=u.mapView;(s.options.cluster||{}).drillToCluster&&n.clusteredData&&(s=n.clusteredData.map(function(t){return t.x}).sort(function(t,e){return t-e}),n=n.clusteredData.map(function(t){return t.y}).sort(function(t,e){return t-e}),i=s[0],s=s[s.length-1],e=n[0],n=n[n.length-1],o=Math.abs(.1*(s-i)),a=Math.abs(.1*(n-e)),r=Math.min(i,s)-o,i=Math.max(i,s)+o,s=Math.min(e,n)-a,o=Math.max(e,n)+a,d?d.fitToBounds({x1:r,x2:i,y1:s,y2:o}):l&&p&&(u.pointer.zoomX=!0,u.pointer.zoomY=!0,u.zoom({originalEvent:t,xAxis:[{axis:l,min:r,max:i}],yAxis:[{axis:p,min:s,max:o}]})))})},o.prototype.getClusterDistancesFromPoint=function(t,e,a){for(var r=[],i=0;i<t.length;i++){var o=D(this,{x:e,y:a}),n=D(this,{x:t[i].posX,y:t[i].posY}),o=Math.sqrt(Math.pow(o.x-n.x,2)+Math.pow(o.y-n.y,2));r.push({clusterIndex:i,distance:o})}return r.sort(function(t,e){return t.distance-e.distance})},o.prototype.getPointsState=function(t,e,a){var r,i,o,n=e?h(e,a):[],s=h(t,a),l={};for(u=[],t.clusters.forEach(function(t){l[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){l[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),o=0;o<s.length;o++)r=s[o],i=n[o],r&&i&&r.parentStateId&&i.parentStateId&&l[r.parentStateId]&&-1===l[r.parentStateId].parentsId.indexOf(i.parentStateId)&&(l[r.parentStateId].parentsId.push(i.parentStateId),-1===u.indexOf(i.parentStateId)&&u.push(i.parentStateId));return l},o.prototype.markerClusterAlgorithms={grid:function(t,e,a,r){for(var i={},o=this.getGridOffset(),n=this.getScaledGridSize(r),s=0;s<t.length;s++){var l=D(this,{x:t[s],y:e[s]}),p=l.x-o.plotLeft,l=l.y-o.plotTop,p=Math.floor(p/n);i[l=Math.floor(l/n)+"-"+p]||(i[l]=[]),i[l].push({dataIndex:a[s],x:t[s],y:e[s]})}return i},kmeans:function(t,e,a,r){var i,o,n,s,l,p,u,d=this,h=[],c=[],f={},m=r.processedDistance||w.layoutAlgorithm.distance,g=r.iterations,x=0,y=!0,C=[];for(l in r.processedGridSize=r.processedDistance,s=d.markerClusterAlgorithms?d.markerClusterAlgorithms.grid.call(d,t,e,a,r):{})1<s[l].length&&(n=T(s[l]),h.push({posX:n.x,posY:n.y,oldX:0,oldY:0,startPointsLen:s[l].length,points:[]}));for(;y;){for(h.map(function(t){return t.points.length=0,t}),p=c.length=0;p<t.length;p++)i=t[p],o=e[p],((C=d.getClusterDistancesFromPoint(h,i,o)).length&&C[0].distance<m?h[C[0].clusterIndex].points:c).push({x:i,y:o,dataIndex:a[p]});for(u=0;u<h.length;u++)1===h[u].points.length&&(C=d.getClusterDistancesFromPoint(h,h[u].points[0].x,h[u].points[0].y))[1].distance<m&&(h[C[1].clusterIndex].points.push(h[u].points[0]),h[C[0].clusterIndex].points.length=0);for(y=!1,u=0;u<h.length;u++)n=T(h[u].points),h[u].oldX=h[u].posX,h[u].oldY=h[u].posY,h[u].posX=n.x,h[u].posY=n.y,(h[u].posX>h[u].oldX+1||h[u].posX<h[u].oldX-1||h[u].posY>h[u].oldY+1||h[u].posY<h[u].oldY-1)&&(y=!0);g&&(y=x<g-1),x++}return h.forEach(function(t,e){f["cluster"+e]=t.points}),c.forEach(function(t,e){f["noise"+e]=[t]}),f},optimizedKmeans:function(t,e,a,r){var i,o,n=this,s=r.processedDistance||w.layoutAlgorithm.gridSize,l={},p=n.getRealExtremes(),u=(n.options.cluster||{}).marker;return!n.markerClusterInfo||n.initMaxX&&n.initMaxX<p.maxX||n.initMinX&&n.initMinX>p.minX||n.initMaxY&&n.initMaxY<p.maxY||n.initMinY&&n.initMinY>p.minY?(n.initMaxX=p.maxX,n.initMinX=p.minX,n.initMaxY=p.maxY,n.initMinY=p.minY,l=n.markerClusterAlgorithms?n.markerClusterAlgorithms.kmeans.call(n,t,e,a,r):{},n.baseClusters=null):(n.baseClusters||(n.baseClusters={clusters:n.markerClusterInfo.clusters,noise:n.markerClusterInfo.noise}),n.baseClusters.clusters.forEach(function(r){r.pointsOutside=[],r.pointsInside=[],r.data.forEach(function(t){var e=D(n,t),a=D(n,r);i=Math.sqrt(Math.pow(e.x-a.x,2)+Math.pow(e.y-a.y,2)),(o=(r.clusterZone&&r.clusterZone.marker&&r.clusterZone.marker.radius?r.clusterZone.marker:u&&u.radius?u:w.marker).radius)+(0<=s-o?s-o:o)<i&&E(r.pointsOutside)?r.pointsOutside.push(t):E(r.pointsInside)&&r.pointsInside.push(t)}),r.pointsInside.length&&(l[r.id]=r.pointsInside),r.pointsOutside.forEach(function(t,e){l[r.id+"_noise"+e]=[t]})}),n.baseClusters.noise.forEach(function(t){l[t.id]=t.data})),l}},o.prototype.preventClusterCollisions=function(t){var a,r,e,i,o,n,s,l,p,u,d,h=this,c=t.key.split("-").map(parseFloat),f=c[0],m=c[1],g=t.gridSize,x=t.groupedData,y=t.defaultRadius,C=t.clusterRadius,I=m*g,k=f*g,c=D(h,t),M=c.x,S=c.y,b=[],A=0,v=(h.options.cluster||{}).marker,X=(h.options.cluster||{}).zones,Y=h.getGridOffset();for(M-=Y.plotLeft,S-=Y.plotTop,o=1;o<5;o++)for(e=o%2?-1:1,i=o<3?-1:1,e=Math.floor((M+e*C)/g),d=[(i=Math.floor((S+i*C)/g))+"-"+e,i+"-"+m,f+"-"+e],n=0;n<d.length;n++)-1===b.indexOf(d[n])&&d[n]!==t.key&&b.push(d[n]);b.forEach(function(t){if(x[t]){x[t].posX||(p=T(x[t]),x[t].posX=p.x,x[t].posY=p.y);var e=D(h,{x:x[t].posX||0,y:x[t].posY||0});if(p=e.x-Y.plotLeft,r=e.y-Y.plotTop,e=t.split("-").map(parseFloat),l=e[0],s=e[1],X)for(a=x[t].length,o=0;o<X.length;o++)a>=X[o].from&&a<=X[o].to&&(A=E((X[o].marker||{}).radius)?X[o].marker.radius||0:(v&&v.radius?v:w.marker).radius);1<x[t].length&&0===A&&v&&v.radius?A=v.radius:1===x[t].length&&(A=y),u=C+A,A=0,s!==m&&Math.abs(M-p)<u&&(M=s-m<0?I+C:I+g-C),l!==f&&Math.abs(S-r)<u&&(S=l-f<0?k+C:k+g-C)}});c=L(h,{x:M+Y.plotLeft,y:S+Y.plotTop});return x[t.key].posX=c.x,x[t.key].posY=c.y,c},o.prototype.isValidGroupedDataObject=function(t){var e,a=!1;return!!v(t)&&(Y(t,function(t){if(a=!0,b(t)&&t.length){for(e=0;e<t.length;e++)if(!v(t[e])||!t[e].x||!t[e].y)return void(a=!1)}else a=!1}),a)},o.prototype.getClusteredData=function(t,e){var a,r,i,o,n,s,l,p,u,d,h,c,f,m=this,g=[],x=[],y=[],C=[],I=[],k=0,M=Math.max(2,e.minimumClusterSize||2);if(A(e.layoutAlgorithm.type)&&!m.isValidGroupedDataObject(t))return S("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,m.chart),!1;for(f in t)if(t[f].length>=M){if(i=t[f],a=O(),n=i.length,e.zones)for(c=0;c<e.zones.length;c++)n>=e.zones[c].from&&n<=e.zones[c].to&&((d=e.zones[c]).zoneIndex=c,u=e.zones[c].marker,h=e.zones[c].className);for(p=T(i),p="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:p.x,y:p.y}:(s=m.options.marker||{},m.preventClusterCollisions({x:p.x,y:p.y,key:f,groupedData:t,gridSize:m.getScaledGridSize(e.layoutAlgorithm),defaultRadius:s.radius||3+(s.lineWidth||0),clusterRadius:u&&u.radius?u.radius:(e.marker||{}).radius||w.marker.radius})),c=0;c<n;c++)i[c].parentStateId=a;if(y.push({x:p.x,y:p.y,id:f,stateId:a,index:k,data:i,clusterZone:d,clusterZoneClassName:h}),g.push(p.x),x.push(p.y),I.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:X(e.marker,{states:e.states},u||{})}}),m.options.data&&m.options.data.length)for(c=0;c<n;c++)v(m.options.data[i[c].dataIndex])&&(i[c].options=m.options.data[i[c].dataIndex]);k++,u=null}else for(c=0;c<t[f].length;c++)r=t[f][c],a=O(),l=null,o=((m.options||{}).data||[])[r.dataIndex],g.push(r.x),x.push(r.y),r.parentStateId=a,C.push({x:r.x,y:r.y,id:f,stateId:a,index:k,data:t[f]}),l=o&&"object"==typeof o&&!b(o)?X(o,{x:r.x,y:r.y}):{userOptions:o,x:r.x,y:r.y},I.push({options:l}),k++;return{clusters:y,noise:C,groupedXData:g,groupedYData:x,groupMap:I}},o.prototype.destroyClusteredData=function(){(this.markerClusterSeriesData||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null},o.prototype.hideClusteredData=function(){var t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=u.map(function(t){return(e[t].point||{}).id||""});(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})},o.prototype.generatePoints=function(){var t,e,a,r,i,o,n=this,s=n.chart,l=s.mapView,p=n.xData,u=n.yData,d=n.options.cluster,h=n.getRealExtremes(),c=[],f=[],m=[];if(l&&n.is("mappoint")&&p&&u&&(n.options.data||[]).forEach(function(t,e){t=n.projectPoint(t);t&&(p[e]=t.x,u[e]=t.y)}),d&&d.enabled&&p&&p.length&&u&&u.length&&!s.polar){l=d.layoutAlgorithm.type,(i=d.layoutAlgorithm).processedGridSize=P(i.gridSize||w.layoutAlgorithm.gridSize,s.plotWidth),i.processedDistance=P(i.distance||w.layoutAlgorithm.distance,s.plotWidth);for(var s=i.kmeansThreshold||w.layoutAlgorithm.kmeansThreshold,g=i.processedGridSize/2,x=L(n,{x:0,y:0}),g=L(n,{x:g,y:g}),y=Math.abs(x.x-g.x),C=Math.abs(x.y-g.y),I=0;I<p.length;I++)n.dataMaxX||(E(e)&&E(t)&&E(r)&&E(a)?M(u[I])&&M(r)&&M(a)&&(e=Math.max(p[I],e),t=Math.min(p[I],t),r=Math.max(u[I]||r,r),a=Math.min(u[I]||a,a)):(e=t=p[I],r=a=u[I])),p[I]>=h.minX-y&&p[I]<=h.maxX+y&&(u[I]||h.minY)>=h.minY-C&&(u[I]||h.maxY)<=h.maxY+C&&(c.push(p[I]),f.push(u[I]),m.push(I));E(e)&&E(t)&&M(r)&&M(a)&&(n.dataMaxX=e,n.dataMinX=t,n.dataMaxY=r,n.dataMinY=a),g=(x=(A(l)?l:n.markerClusterAlgorithms?l&&n.markerClusterAlgorithms[l]?n.markerClusterAlgorithms[l]:c.length<s?n.markerClusterAlgorithms.kmeans:n.markerClusterAlgorithms.grid:function(){return!1}).call(this,c,f,m,i))&&n.getClusteredData(x,d),s=d.animation&&n.markerClusterInfo&&n.markerClusterInfo.pointsState&&n.markerClusterInfo.pointsState.oldState?((l=n.markerClusterInfo.pointsState.oldState)&&Y(l,function(t){t.point&&t.point.destroy&&t.point.destroy()}),n.markerClusterInfo.pointsState.newState):{},i=p.length,x=n.markerClusterInfo,g&&(n.processedXData=g.groupedXData,n.processedYData=g.groupedYData,n.hasGroupedData=!0,n.markerClusterInfo=g,n.groupMap=g.groupMap),z.apply(this),g&&n.markerClusterInfo&&((n.markerClusterInfo.clusters||[]).forEach(function(t){(o=n.points[t.index]).isCluster=!0,o.clusteredData=t.data,o.clusterPointsAmount=t.data.length,t.point=o,k(o,"click",n.onDrillToCluster)}),(n.markerClusterInfo.noise||[]).forEach(function(t){t.point=n.points[t.index]}),d.animation&&n.markerClusterInfo&&(n.markerClusterInfo.pointsState={oldState:s,newState:n.getPointsState(g,x,i)}),d.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else z.apply(this)},k(e,"render",function(){(this.series||[]).forEach(function(e){var t,a;e.markerClusterInfo&&(t=e.options.cluster,a=((e.markerClusterInfo||{}).pointsState||{}).oldState,(t||{}).animation&&e.markerClusterInfo&&0===e.chart.pointer.pinchDown.length&&"pan"!==((e.xAxis||{}).eventArgs||{}).trigger&&a&&Object.keys(a).length&&(e.markerClusterInfo.clusters.forEach(function(t){e.animateClusterPoint(t)}),e.markerClusterInfo.noise.forEach(function(t){e.animateClusterPoint(t)})))})}),k(r,"update",function(){if(this.dataGroup)return S("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}),k(i,"destroy",o.prototype.destroyClusteredData),k(i,"afterRender",function(){var e=(this.options.cluster||{}).drillToCluster;this.markerClusterInfo&&this.markerClusterInfo.clusters&&this.markerClusterInfo.clusters.forEach(function(t){t.point&&t.point.graphic&&(t.point.graphic.addClass("highcharts-cluster-point"),e&&t.point&&(t.point.graphic.css({cursor:"pointer"}),t.point.dataLabel&&t.point.dataLabel.css({cursor:"pointer"})),E(t.clusterZone)&&t.point.graphic.addClass(t.clusterZoneClassName||"highcharts-cluster-zone-"+t.clusterZone.zoneIndex))})}),k(r,"drillToCluster",function(t){var e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;A(e)&&e.call(this,t)}),k(l,"setExtremes",function(){var e,t=this.chart,a=0;t.series.forEach(function(t){t.markerClusterInfo&&(e=m((t.options.cluster||{}).animation),a=e.duration||0)}),g(function(){t.tooltip&&t.tooltip.destroy()},a)})}),e(t,"masters/modules/marker-clusters.src.js",[],function(){})});