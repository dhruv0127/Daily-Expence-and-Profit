"use strict";import PC from"../Core/Geometry/PolygonClip.js";const{clipLineString,clipPolygon}=PC;import registry from"./Projections/ProjectionRegistry.js";import U from"../Core/Utilities.js";const{clamp,erase}=U,deg2rad=2*Math.PI/360,floatCorrection=1e-6,wrapLon=t=>(t<-180&&(t+=360),180<t&&(t-=360),t);class Projection{static add(t,r){Projection.registry[t]=r}static greatCircle(t,r,e){const{atan2:o,cos:i,sin:a,sqrt:n}=Math;var s=t[1]*deg2rad,c=t[0]*deg2rad,h=r[1]*deg2rad,l=r[0]*deg2rad,d=h-s,f=l-c,d=a(d/2)*a(d/2)+i(s)*i(h)*a(f/2)*a(f/2),g=2*o(n(d),n(1-d)),f=Math.round(6371e3*g/5e5);const u=[];if(e&&u.push(t),1<f){var p=1/f;for(let t=p;t<.999;t+=p){var M=a((1-t)*g)/a(g),v=a(t*g)/a(g),y=M*i(s)*i(c)+v*i(h)*i(l),P=M*i(s)*a(c)+v*i(h)*a(l),M=M*a(s)+v*a(h),v=o(M,n(y*y+P*P)),M=o(P,y);u.push([M/deg2rad,v/deg2rad])}}return e&&u.push(r),u}static insertGreatCircles(t){let r=t.length-1;for(;r--;){var e;10<Math.max(Math.abs(t[r][0]-t[r+1][0]),Math.abs(t[r][1]-t[r+1][1]))&&((e=Projection.greatCircle(t[r],t[r+1])).length&&t.splice(r+1,0,...e))}}static toString(t){const{name:r,rotation:e}=t||{};return[r,e&&e.join(",")].join(";")}constructor(t={}){this.hasCoordinates=!1,this.hasGeoProjection=!1,this.maxLatitude=90;var{name:r,projectedBounds:e,rotation:o}=this.options=t;this.rotator=o?this.getRotator(o):void 0;const i=r?Projection.registry[r]:void 0,{def:a,rotator:n}=(i&&(this.def=new i(t)),this);a&&(this.maxLatitude=a.maxLatitude||90,this.hasGeoProjection=!0),n&&a?(this.forward=t=>a.forward(n.forward(t)),this.inverse=t=>n.inverse(a.inverse(t))):a?(this.forward=t=>a.forward(t),this.inverse=t=>a.inverse(t)):n&&(this.forward=n.forward,this.inverse=n.inverse),this.bounds="world"===e?a&&a.bounds:e}lineIntersectsBounds(t){var{x1:r,x2:e,y1:o,y2:i}=this.bounds||{},a=(t,r,e)=>{var o,[t,i]=t,a=r?0:1;if("number"==typeof e&&t[r]>=e!=i[r]>=e)return o=(e-t[r])/(i[r]-t[r]),o=t[a]+o*(i[a]-t[a]),r?[o,e]:[e,o]};let n,s=t[0];return((n=a(t,0,r))||(n=a(t,0,e)))&&(s=n,t[1]=n),s=(n=a(t,1,o))||(n=a(t,1,i))?n:s}getRotator(t){const i=t[0]*deg2rad,r=(t[1]||0)*deg2rad,e=(t[2]||0)*deg2rad,a=Math.cos(r),n=Math.sin(r),s=Math.cos(e),c=Math.sin(e);if(0!=i||0!=r||0!=e)return{forward:t=>{var r=t[0]*deg2rad+i,t=t[1]*deg2rad,e=Math.cos(t),o=Math.cos(r)*e,r=Math.sin(r)*e,e=Math.sin(t),t=e*a+o*n;return[Math.atan2(r*s-t*c,o*a-e*n)/deg2rad,Math.asin(t*s+r*c)/deg2rad]},inverse:t=>{var r=t[0]*deg2rad,t=t[1]*deg2rad,e=Math.cos(t),o=Math.cos(r)*e,r=Math.sin(r)*e,e=Math.sin(t),t=e*s-r*c;return[(Math.atan2(r*s+e*c,o*a+t*n)-i)/deg2rad,Math.asin(t*a-o*n)/deg2rad]}}}forward(t){return t}inverse(t){return t}cutOnAntimeridian(a,n){const s=[],r=[a];a.forEach((t,r)=>{let e=a[r-1];if(!r){if(!n)return;e=a[a.length-1]}var o=e[0],i=t[0];(o<-90||90<o)&&(i<-90||90<i)&&0<o!=0<i&&(i=clamp((180-(o+360)%360)/((i+360)%360-(o+360)%360),0,1),i=e[1]+i*(t[1]-e[1]),s.push({i:r,lat:i,direction:o<0?1:-1,previousLonLat:e,lonLat:t}))});let e;if(s.length)if(n){s.length%2==1&&(e=s.slice().sort((t,r)=>Math.abs(r.lat)-Math.abs(t.lat))[0],erase(s,e));let t=s.length-2;for(;0<=t;){var o=s[t].i,i=wrapLon(180+s[t].direction*floatCorrection),c=wrapLon(180-s[t].direction*floatCorrection);const g=a.splice(o,s[t+1].i-o,...Projection.greatCircle([i,s[t].lat],[i,s[t+1].lat],!0));g.push(...Projection.greatCircle([c,s[t+1].lat],[c,s[t].lat],!0)),r.push(g),t-=2}if(e)for(let t=0;t<r.length;t++){const{direction:u,lat:p}=e,a=r[t],M=a.indexOf(e.lonLat);if(-1<M){var h=(p<0?-1:1)*this.maxLatitude,l=wrapLon(180+u*floatCorrection),d=wrapLon(180-u*floatCorrection);const v=Projection.greatCircle([l,p],[l,h],!0);for(let t=l+120*u;-180<t&&t<180;t+=120*u)v.push([t,h]);v.push(...Projection.greatCircle([d,h],[d,e.lat],!0)),a.splice(M,0,...v);break}}}else{let t=s.length;for(;t--;){var f=s[t].i;const y=a.splice(f,a.length,[wrapLon(180+s[t].direction*floatCorrection),s[t].lat]);y.unshift([wrapLon(180-s[t].direction*floatCorrection),s[t].lat]),r.push(y)}}return r}path(t){const{bounds:g,def:r,rotator:e}=this,u=[],p="Polygon"===t.type||"MultiPolygon"===t.type,M=this.hasGeoProjection,v=!r||!1!==r.antimeridianCutting,o=v?e:void 0,y=v&&r||this;let P;g&&(P=[[g.x1,g.y1],[g.x2,g.y1],[g.x2,g.y2],[g.x1,g.y2]]);const i=t=>{t=t.map(r=>{if(v){let t=(r=o?o.forward(r):r)[0];r=[t=Math.abs(t-180)<floatCorrection?t<180?180-floatCorrection:180+floatCorrection:t,r[1]]}return r});let r=[t];M&&(Projection.insertGreatCircles(t),v&&(r=this.cutOnAntimeridian(t,p))),r.forEach(c=>{if(!(c.length<2)){let r=!1,e,o,i=!1;const d=t=>{r?u.push(["L",t[0],t[1]]):(u.push(["M",t[0],t[1]]),r=!0)};let a=!1,n=!1,s=c.map(t=>{const r=y.forward(t);return r.outside?a=!0:n=!0,r[1]===1/0?r[1]=1e10:r[1]===-1/0&&(r[1]=-1e10),r});if(v){if(p&&s.push(s[0]),a){if(!n)return;if(P)if(p)s=clipPolygon(s,P);else if(g)return void clipLineString(s,P).forEach(t=>{r=!1,t.forEach(d)})}s.forEach(d)}else for(let t=0;t<s.length;t++){var h=c[t],l=s[t];if(l.outside)i=!0;else{if(p&&!e&&(e=h,c.push(h),s.push(l)),i&&o)if(p&&M){const f=Projection.greatCircle(o,h);f.forEach(t=>d(y.forward(t)))}else r=!1;d(l),o=h,i=!1}}}})};return"LineString"===t.type?i(t.coordinates):"MultiLineString"===t.type?t.coordinates.forEach(t=>i(t)):"Polygon"===t.type?(t.coordinates.forEach(t=>i(t)),u.length&&u.push(["Z"])):"MultiPolygon"===t.type&&(t.coordinates.forEach(t=>{t.forEach(t=>i(t))}),u.length&&u.push(["Z"])),u}}Projection.registry=registry;export default Projection;