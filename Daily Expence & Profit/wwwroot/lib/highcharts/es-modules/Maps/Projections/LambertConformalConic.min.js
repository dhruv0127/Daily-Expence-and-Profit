"use strict";const sign=Math.sign||(a=>0===a?0:0<a?1:-1),scale=63.78137,deg2rad=Math.PI/180,halfPI=Math.PI/2,eps10=1e-6,tany=a=>Math.tan((halfPI+a)/2);class LambertConformalConic{constructor(a){var t=(a.parallels||[]).map(a=>a*deg2rad),s=t[0]||0,t=null!=(t=t[1])?t:s,e=Math.cos(s);"object"==typeof a.projectedBounds&&(this.projectedBounds=a.projectedBounds);let n=s===t?Math.sin(s):Math.log(e/Math.cos(t))/Math.log(tany(t)/tany(s));Math.abs(n)<1e-10&&(n=1e-10*(sign(n)||1)),this.n=n,this.c=e*Math.pow(tany(s),n)/n}forward(a){var t=a[0]*deg2rad,{c:s,n:e,projectedBounds:n}=this;let h=a[1]*deg2rad;0<s?h<-halfPI+eps10&&(h=-halfPI+eps10):h>halfPI-eps10&&(h=halfPI-eps10);const o=s/Math.pow(tany(h),e),r=o*Math.sin(e*t)*scale,l=(s-o*Math.cos(e*t))*scale,c=[r,l];return n&&(r<n.x1||r>n.x2||l<n.y1||l>n.y2)&&(c.outside=!0),c}inverse(a){var t=a[0]/scale,{c:s,n:e}=this,a=s-a[1]/scale,n=sign(e)*Math.sqrt(t*t+a*a);let h=Math.atan2(t,Math.abs(a))*sign(a);return a*e<0&&(h-=Math.PI*sign(t)*sign(a)),[h/e/deg2rad,(2*Math.atan(Math.pow(s/n,1/e))-halfPI)/deg2rad]}}export default LambertConformalConic;