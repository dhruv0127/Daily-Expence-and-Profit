"use strict";import Connection from"./Connection.js";import Chart from"../Core/Chart/Chart.js";import D from"../Core/Defaults.js";const defaultOptions=D["defaultOptions"];import H from"../Core/Globals.js";import Point from"../Core/Series/Point.js";import U from"../Core/Utilities.js";const{addEvent,defined,error,extend,merge,pick,splat}=U;import pathfinderAlgorithms from"./PathfinderAlgorithms.js";const max=Math.max,min=Math.min;function getPointBB(t){var n=t.shapeArgs;return n?{xMin:n.x||0,xMax:(n.x||0)+(n.width||0),yMin:n.y||0,yMax:(n.y||0)+(n.height||0)}:(n=t.graphic&&t.graphic.getBBox())?{xMin:t.plotX-n.width/2,xMax:t.plotX+n.width/2,yMin:t.plotY-n.height/2,yMax:t.plotY+n.height/2}:null}function calculateObstacleMargin(t){function s(t,n,i){var i=pick(i,10),e=t.yMax+i>n.yMin-i&&t.yMin-i<n.yMax+i,o=t.xMax+i>n.xMin-i&&t.xMin-i<n.xMax+i,r=e?t.xMin>n.xMax?t.xMin-n.xMax:n.xMin-t.xMax:1/0,a=o?t.yMin>n.yMax?t.yMin-n.yMax:n.yMin-t.yMax:1/0;return o&&e?i?s(t,n,Math.floor(i/2)):1/0:min(r,a)}let n=t.length,i=0,e,o,r=[];for(;i<n;++i)for(e=i+1;e<n;++e)(o=s(t[i],t[e]))<80&&r.push(o);return r.push(80),max(Math.floor(r.sort(function(t,n){return t-n})[Math.floor(r.length/10)]/2-1),1)}extend(defaultOptions,{connectors:{type:"straight",lineWidth:1,marker:{enabled:!1,align:"center",verticalAlign:"middle",inside:!1,lineWidth:1},startMarker:{symbol:"diamond"},endMarker:{symbol:"arrow-filled"}}});class Pathfinder{constructor(t){this.chart=void 0,this.chartObstacles=void 0,this.chartObstacleMetrics=void 0,this.connections=void 0,this.group=void 0,this.lineObstacles=void 0,this.init(t)}init(t){this.chart=t,this.connections=[],addEvent(t,"redraw",function(){this.pathfinder.update()})}update(t){const o=this.chart,r=this,a=r.connections;r.connections=[],o.series.forEach(function(t){t.visible&&!t.options.isInternal&&t.points.forEach(function(n){const t=n.options;t&&t.dependency&&(t.connect=t.dependency);let i,e=n.options&&n.options.connect&&splat(n.options.connect);n.visible&&!1!==n.isInside&&e&&e.forEach(function(t){(i=o.get("string"==typeof t?t:t.to))instanceof Point&&i.series.visible&&i.visible&&!1!==i.isInside&&r.connections.push(new Connection(n,i,"string"==typeof t?{}:t))})})});for(let t=0,n,i,e=a.length,o=r.connections.length;t<e;++t){i=!1;const s=a[t];for(n=0;n<o;++n){const c=r.connections[n];if((s.options&&s.options.type)===(c.options&&c.options.type)&&s.fromPoint===c.fromPoint&&s.toPoint===c.toPoint){c.graphics=s.graphics,i=!0;break}}i||s.destroy()}delete this.chartObstacles,delete this.lineObstacles,r.renderConnections(t)}renderConnections(t){t?this.chart.series.forEach(function(i){function t(){const t=i.chart.pathfinder,n=t&&t.connections||[];n.forEach(function(t){t.fromPoint&&t.fromPoint.series===i&&t.render()}),i.pathfinderRemoveRenderEvent&&(i.pathfinderRemoveRenderEvent(),delete i.pathfinderRemoveRenderEvent)}!1===i.options.animation?t():i.pathfinderRemoveRenderEvent=addEvent(i,"afterAnimate",t)}):this.connections.forEach(function(t){t.render()})}getChartObstacles(t){let r=[],a=this.chart.series,s=pick(t.algorithmMargin,0),n;for(let o=0,t=a.length;o<t;++o)if(a[o].visible&&!a[o].options.isInternal)for(let t=0,n=a[o].points.length,i,e;t<n;++t)(e=a[o].points[t]).visible&&(i=getPointBB(e))&&r.push({xMin:i.xMin-s,xMax:i.xMax+s,yMin:i.yMin-s,yMax:i.yMax+s});return r=r.sort(function(t,n){return t.xMin-n.xMin}),defined(t.algorithmMargin)||(n=t.algorithmMargin=calculateObstacleMargin(r),r.forEach(function(t){t.xMin-=n,t.xMax+=n,t.yMin-=n,t.yMax+=n})),r}getObstacleMetrics(t){let n=0,i=0,e,o,r=t.length;for(;r--;)e=t[r].xMax-t[r].xMin,o=t[r].yMax-t[r].yMin,n<e&&(n=e),i<o&&(i=o);return{maxHeight:i,maxWidth:n}}getAlgorithmStartDirection(t){var n="left"!==t.align&&"right"!==t.align,t="top"!==t.verticalAlign&&"bottom"!==t.verticalAlign;return n?t&&void 0:t||void 0}}function warnLegacy(t){(t.options.pathfinder||t.series.reduce(function(t,n){return n.options&&merge(!0,n.options.connectors=n.options.connectors||{},n.options.pathfinder),t||n.options&&n.options.pathfinder},!1))&&(merge(!0,t.options.connectors=t.options.connectors||{},t.options.pathfinder),error('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.'))}Pathfinder.prototype.algorithms=pathfinderAlgorithms,H.Pathfinder=Pathfinder,extend(Point.prototype,{getPathfinderAnchorPoint:function(t){let n=getPointBB(this),i,e;switch(t.align){case"right":i="xMax";break;case"left":i="xMin"}switch(t.verticalAlign){case"top":e="yMin";break;case"bottom":e="yMax"}return{x:i?n[i]:(n.xMin+n.xMax)/2,y:e?n[e]:(n.yMin+n.yMax)/2}},getRadiansToVector:function(t,n){var i;return defined(n)||(i=getPointBB(this))&&(n={x:(i.xMin+i.xMax)/2,y:(i.yMin+i.yMax)/2}),Math.atan2(n.y-t.y,t.x-n.x)},getMarkerVector:function(t,n,i){let e=2*Math.PI,o=t,r=getPointBB(this),a=r.xMax-r.xMin,s=r.yMax-r.yMin,c=Math.atan2(s,a),h,l=!1,d=a/2,f=s/2,M=r.xMin+d,p=r.yMin+f,x={x:M,y:p},g=1,y=1;for(;o<-Math.PI;)o+=e;for(;o>Math.PI;)o-=e;return h=Math.tan(o),o>-c&&o<=c?(y=-1,l=!0):o>c&&o<=Math.PI-c?y=-1:o>Math.PI-c||o<=-(Math.PI-c)?(g=-1,l=!0):g=-1,l?(x.x+=g*d,x.y+=y*d*h):(x.x+=g*(s/(2*h)),x.y+=y*f),i.x!==M&&(x.x=i.x),i.y!==p&&(x.y=i.y),{x:x.x+n*Math.cos(o),y:x.y-n*Math.sin(o)}}}),Chart.prototype.callbacks.push(function(t){!1!==t.options.connectors.enabled&&(warnLegacy(t),this.pathfinder=new Pathfinder(this),this.pathfinder.update(!0))});export default Pathfinder;