"use strict";import U from"../Core/Utilities.js";const{extend,pick}=U,{min,max,abs}=Math;function findLastObstacleBefore(t,n,a){let x=a||0,i=t.length-1,e=n-1e-7,s,r;for(;x<=i;)if(0<(r=e-t[s=i+x>>1].xMin))x=1+s;else{if(!(r<0))return s;i=s-1}return 0<x?x-1:0}function pointWithinObstacle(t,n){return n.x<=t.xMax&&n.x>=t.xMin&&n.y<=t.yMax&&n.y>=t.yMin}function findObstacleFromPoint(t,n){let a=findLastObstacleBefore(t,n.x+1)+1;for(;a--;)if(t[a].xMax>=n.x&&pointWithinObstacle(t[a],n))return a;return-1}function pathFromSegments(n){const a=[];if(n.length){a.push(["M",n[0].start.x,n[0].start.y]);for(let t=0;t<n.length;++t)a.push(["L",n[t].end.x,n[t].end.y])}return a}function limitObstacleToBounds(t,n){t.yMin=max(t.yMin,n.yMin),t.yMax=min(t.yMax,n.yMax),t.xMin=max(t.xMin,n.xMin),t.xMax=min(t.xMax,n.xMax)}function straight(t,n){return{path:[["M",t.x,t.y],["L",n.x,n.y]],obstacles:[{start:t,end:n}]}}const simpleConnect=function(t,n,a){let x=[],i,e=pick(a.startDirectionX,abs(n.x-t.x)>abs(n.y-t.y))?"x":"y",s=a.chartObstacles,r=findObstacleFromPoint(s,t),o=findObstacleFromPoint(s,n),y,M,c,l,d,u,f;function m(t,n,a,x,i){const e={x:t.x,y:t.y};return e[n]=a[x||n]+(i||0),e}function h(t,n,a){var x=abs(n[a]-t[a+"Min"])>abs(n[a]-t[a+"Max"]);return m(n,a,t,a+(x?"Max":"Min"),x?1:-1)}return f=-1<o?(M=s[o],l=h(M,n,e),i={start:l,end:n},l):n,-1<r&&(y=s[r],l=h(y,t,e),x.push({start:t,end:l}),l[e]>=t[e]==l[e]>=f[e]&&(u=t[e="y"===e?"x":"y"]<n[e],x.push({start:l,end:m(l,e,y,e+(u?"Max":"Min"),u?1:-1)}),e="y"===e?"x":"y")),c=x.length?x[x.length-1].end:t,l=m(c,e,f),x.push({start:c,end:l}),e="y"===e?"x":"y",d=m(l,e,f),x.push({start:l,end:d}),x.push(i),{path:pathFromSegments(x),obstacles:x}},fastAvoid=(simpleConnect.requiresObstacles=!0,function(t,n,u){let a=pick(u.startDirectionX,abs(n.x-t.x)>abs(n.y-t.y)),x=a?"x":"y",i,e,s,r=[],f=!1,o=u.obstacleMetrics,m=min(t.x,n.x)-o.maxWidth-10,h=max(t.x,n.x)+o.maxWidth+10,b=min(t.y,n.y)-o.maxHeight-10,p=max(t.y,n.y)+o.maxHeight+10,O=u.chartObstacles,y=findLastObstacleBefore(O,m),M=findLastObstacleBefore(O,h);function g(t,n,a){let x,i,e,s,r,o=t.x<n.x?1:-1;for(i=t.x<n.x?(x=t,n):(x=n,t),e=t.y<n.y?(s=t,n):(s=n,t),r=o<0?min(findLastObstacleBefore(O,i.x),O.length-1):0;O[r]&&(0<o&&O[r].xMin<=i.x||o<0&&O[r].xMax>=x.x);){if(O[r].xMin<=i.x&&O[r].xMax>=x.x&&O[r].yMin<=e.y&&O[r].yMax>=s.y)return a?{y:t.y,x:t.x<n.x?O[r].xMin-1:O[r].xMax+1,obstacle:O[r]}:{x:t.x,y:t.y<n.y?O[r].yMin-1:O[r].yMax+1,obstacle:O[r]};r+=o}return n}function B(t,n,a,x,i){let e=i.soft,s=i.hard,r=x?"x":"y",o={x:n.x,y:n.y},y={x:n.x,y:n.y},M,c,l=t[r+"Max"]>=e[r+"Max"],d=t[r+"Min"]<=e[r+"Min"],u=t[r+"Max"]>=s[r+"Max"],f=t[r+"Min"]<=s[r+"Min"],m=abs(t[r+"Min"]-n[r]),h=abs(t[r+"Max"]-n[r]),b=abs(m-h)<10?n[r]<a[r]:h<m;return y[r]=t[r+"Min"],o[r]=t[r+"Max"],M=g(n,y,x)[r]!==y[r],c=g(n,o,x)[r]!==o[r],b=M?!c||b:!c&&b,b=d?!l||b:!l&&b,b=f?!u||b:!u&&b}var c,l,d,F;for(O=O.slice(y,M+1),-1<(M=findObstacleFromPoint(O,n))&&(s=(c=O[M],l=n,d=t,F=min(c.xMax-l.x,l.x-c.xMin)<min(c.yMax-l.y,l.y-c.yMin),d=B(c,l,d,F,{soft:u.hardBounds,hard:u.hardBounds}),F?{y:l.y,x:c[d?"xMax":"xMin"]+(d?1:-1)}:{x:l.x,y:c[d?"yMax":"yMin"]+(d?1:-1)}),r.push({end:n,start:s}),n=s);-1<(M=findObstacleFromPoint(O,n));)e=n[x]-t[x]<0,(s={x:n.x,y:n.y})[x]=O[M][e?x+"Max":x+"Min"]+(e?1:-1),r.push({end:n,start:s}),n=s;return{path:pathFromSegments(i=(i=function t(n,a,x){if(n.x===a.x&&n.y===a.y)return[];let i=x?"x":"y",e,s,r,o,y,M,c,l=u.obstacleOptions.margin,d={soft:{xMin:m,xMax:h,yMin:b,yMax:p},hard:u.hardBounds};return-1<(y=findObstacleFromPoint(O,n))?(y=O[y],o=B(y,n,a,x,d),limitObstacleToBounds(y,u.hardBounds),c=x?{y:n.y,x:y[o?"xMax":"xMin"]+(o?1:-1)}:{x:n.x,y:y[o?"yMax":"yMin"]+(o?1:-1)},-1<(M=findObstacleFromPoint(O,c))&&(limitObstacleToBounds(M=O[M],u.hardBounds),c[i]=o?max(y[i+"Max"]-l+1,(M[i+"Min"]+y[i+"Max"])/2):min(y[i+"Min"]+l-1,(M[i+"Max"]+y[i+"Min"])/2),f=n.x===c.x&&n.y===c.y&&(f&&(c[i]=o?max(y[i+"Max"],M[i+"Max"])+1:min(y[i+"Min"],M[i+"Min"])-1),!f)),s=[{start:n,end:c}]):(e=g(n,{x:(x?a:n).x,y:(x?n:a).y},x),s=[{start:n,end:{x:e.x,y:e.y}}],e[x?"x":"y"]!==a[x?"x":"y"]&&(o=B(e.obstacle,e,a,!x,d),limitObstacleToBounds(e.obstacle,u.hardBounds),r={x:x?e.x:e.obstacle[o?"xMax":"xMin"]+(o?1:-1),y:x?e.obstacle[o?"yMax":"yMin"]+(o?1:-1):e.y},x=!x,s=s.concat(t({x:e.x,y:e.y},r,x)))),s=s.concat(t(s[s.length-1].end,a,!x))}(t,n,a)).concat(r.reverse())),obstacles:i}}),algorithms=(fastAvoid.requiresObstacles=!0,{fastAvoid:fastAvoid,straight:straight,simpleConnect:simpleConnect});export default algorithms;