"use strict";import D from"../Core/Defaults.js";const defaultOptions=D["defaultOptions"];import H from"../Core/Globals.js";import Point from"../Core/Series/Point.js";import U from"../Core/Utilities.js";const{defined,error,extend,merge,objectEach,pick}=U,deg2rad=H.deg2rad,max=Math.max,min=Math.min;function getPointBB(t){var i=t.shapeArgs;return i?{xMin:i.x||0,xMax:(i.x||0)+(i.width||0),yMin:i.y||0,yMax:(i.y||0)+(i.height||0)}:(i=t.graphic&&t.graphic.getBBox())?{xMin:t.plotX-i.width/2,xMax:t.plotX+i.width/2,yMin:t.plotY-i.height/2,yMax:t.plotY+i.height/2}:null}function calculateObstacleMargin(t){function s(t,i,r){var r=pick(r,10),e=t.yMax+r>i.yMin-r&&t.yMin-r<i.yMax+r,a=t.xMax+r>i.xMin-r&&t.xMin-r<i.xMax+r,o=e?t.xMin>i.xMax?t.xMin-i.xMax:i.xMin-t.xMax:1/0,n=a?t.yMin>i.yMax?t.yMin-i.yMax:i.yMin-t.yMax:1/0;return a&&e?r?s(t,i,Math.floor(r/2)):1/0:min(o,n)}let i=t.length,r=0,e,a,o=[];for(;r<i;++r)for(e=r+1;e<i;++e)(a=s(t[r],t[e]))<80&&o.push(a);return o.push(80),max(Math.floor(o.sort(function(t,i){return t-i})[Math.floor(o.length/10)]/2-1),1)}extend(defaultOptions,{connectors:{type:"straight",lineWidth:1,marker:{enabled:!1,align:"center",verticalAlign:"middle",inside:!1,lineWidth:1},startMarker:{symbol:"diamond"},endMarker:{symbol:"arrow-filled"}}});class Connection{constructor(t,i,r){this.chart=void 0,this.fromPoint=void 0,this.graphics=void 0,this.pathfinder=void 0,this.toPoint=void 0,this.init(t,i,r)}init(t,i,r){this.fromPoint=t,this.toPoint=i,this.options=r,this.chart=t.series.chart,this.pathfinder=this.chart.pathfinder}renderPath(t,i,r){let e=this.chart,a=e.styledMode,o=e.pathfinder,n=!e.options.chart.forExport&&!1!==r,s=this.graphics&&this.graphics.path,h;o.group||(o.group=e.renderer.g().addClass("highcharts-pathfinder-group").attr({zIndex:-1}).add(e.seriesGroup)),o.group.translate(e.plotLeft,e.plotTop),s&&s.renderer||(s=e.renderer.path().add(o.group),a||s.attr({opacity:0})),s.attr(i),h={d:t},a||(h.opacity=1),s[n?"animate":"attr"](h,r),this.graphics=this.graphics||{},this.graphics.path=s}addMarker(t,i,r){let e=this,a=e.fromPoint.series.chart,o=a.pathfinder,n=a.renderer,s="start"===t?e.fromPoint:e.toPoint,h=s.getPathfinderAnchorPoint(i),c,d,l,p,g,M,x,y;i.enabled&&((y="start"===t?r[1]:r[r.length-2])&&"M"===y[0]||"L"===y[0])&&(x={x:y[1],y:y[2]},d=s.getRadiansToVector(x,h),c=s.getMarkerVector(d,i.radius,h),l=-d/deg2rad,i.width&&i.height?(g=i.width,M=i.height):g=M=2*i.radius,e.graphics=e.graphics||{},p={x:c.x-g/2,y:c.y-M/2,width:g,height:M,rotation:l,rotationOriginX:c.x,rotationOriginY:c.y},e.graphics[t]?e.graphics[t].animate(p):(e.graphics[t]=n.symbol(i.symbol).addClass("highcharts-point-connecting-path-"+t+"-marker").attr(p).add(o.group),n.styledMode||e.graphics[t].attr({fill:i.color||e.fromPoint.color,stroke:i.lineColor,"stroke-width":i.lineWidth,opacity:0}).animate({opacity:1},s.series.options.animation)))}getPath(t){let i=this.pathfinder,r=this.chart,e=i.algorithms[t.type],a=i.chartObstacles;return"function"!=typeof e?(error('"'+t.type+'" is not a Pathfinder algorithm.'),{path:[],obstacles:[]}):(e.requiresObstacles&&!a&&(a=i.chartObstacles=i.getChartObstacles(t),r.options.connectors.algorithmMargin=t.algorithmMargin,i.chartObstacleMetrics=i.getObstacleMetrics(a)),e(this.fromPoint.getPathfinderAnchorPoint(t.startMarker),this.toPoint.getPathfinderAnchorPoint(t.endMarker),merge({chartObstacles:a,lineObstacles:i.lineObstacles||[],obstacleMetrics:i.chartObstacleMetrics,hardBounds:{xMin:0,xMax:r.plotWidth,yMin:0,yMax:r.plotHeight},obstacleOptions:{margin:t.algorithmMargin},startDirectionX:i.getAlgorithmStartDirection(t.startMarker)},t)))}render(){let t=this,i=t.fromPoint,r=i.series,e=r.chart,a=e.pathfinder,o,n,s=merge(e.options.connectors,r.options.connectors,i.options.connectors,t.options),h={};e.styledMode||(h.stroke=s.lineColor||i.color,h["stroke-width"]=s.lineWidth,s.dashStyle&&(h.dashstyle=s.dashStyle)),h.class="highcharts-point-connecting-path highcharts-color-"+i.colorIndex,s=merge(h,s),defined(s.marker.radius)||(s.marker.radius=min(max(Math.ceil((s.algorithmMargin||8)/2)-1,1),5)),n=(o=t.getPath(s)).path,o.obstacles&&(a.lineObstacles=a.lineObstacles||[],a.lineObstacles=a.lineObstacles.concat(o.obstacles)),t.renderPath(n,h,r.options.animation),t.addMarker("start",merge(s.marker,s.startMarker),n),t.addMarker("end",merge(s.marker,s.endMarker),n)}destroy(){this.graphics&&(objectEach(this.graphics,function(t){t.destroy()}),delete this.graphics)}}function warnLegacy(t){(t.options.pathfinder||t.series.reduce(function(t,i){return i.options&&merge(!0,i.options.connectors=i.options.connectors||{},i.options.pathfinder),t||i.options&&i.options.pathfinder},!1))&&(merge(!0,t.options.connectors=t.options.connectors||{},t.options.pathfinder),error('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.'))}H.Connection=Connection,extend(Point.prototype,{getPathfinderAnchorPoint:function(t){let i=getPointBB(this),r,e;switch(t.align){case"right":r="xMax";break;case"left":r="xMin"}switch(t.verticalAlign){case"top":e="yMin";break;case"bottom":e="yMax"}return{x:r?i[r]:(i.xMin+i.xMax)/2,y:e?i[e]:(i.yMin+i.yMax)/2}},getRadiansToVector:function(t,i){var r;return defined(i)||(r=getPointBB(this))&&(i={x:(r.xMin+r.xMax)/2,y:(r.yMin+r.yMax)/2}),Math.atan2(i.y-t.y,t.x-i.x)},getMarkerVector:function(t,i,r){let e=2*Math.PI,a=t,o=getPointBB(this),n=o.xMax-o.xMin,s=o.yMax-o.yMin,h=Math.atan2(s,n),c,d=!1,l=n/2,p=s/2,g=o.xMin+l,M=o.yMin+p,x={x:g,y:M},y=1,f=1;for(;a<-Math.PI;)a+=e;for(;a>Math.PI;)a-=e;return c=Math.tan(a),a>-h&&a<=h?(f=-1,d=!0):a>h&&a<=Math.PI-h?f=-1:a>Math.PI-h||a<=-(Math.PI-h)?(y=-1,d=!0):y=-1,d?(x.x+=y*l,x.y+=f*l*c):(x.x+=y*(s/(2*c)),x.y+=f*p),r.x!==g&&(x.x=r.x),r.y!==M&&(x.y=r.y),{x:x.x+i*Math.cos(a),y:x.y-i*Math.sin(a)}}});export default Connection;