"use strict";import ApproximationRegistry from"../../../Extensions/DataGrouping/ApproximationRegistry.js";import Color from"../../../Core/Color/Color.js";const color=Color["parse"];import SeriesRegistry from"../../../Core/Series/SeriesRegistry.js";const SMAIndicator=SeriesRegistry.seriesTypes["sma"];import U from"../../../Core/Utilities.js";const{defined,extend,isArray,isNumber,merge,objectEach}=U;function maxHigh(o){return o.reduce(function(o,e){return Math.max(o,e[1])},-1/0)}function minLow(o){return o.reduce(function(o,e){return Math.min(o,e[2])},1/0)}function highlowLevel(o){return{high:maxHigh(o),low:minLow(o)}}function getClosestPointRange(o){let e,t,n,i,s;return o.series.forEach(function(o){if(o.xData)for(i=o.xData,t=o.xIncrement?1:i.length-1,s=t;0<s;s--)n=i[s]-i[s-1],(void 0===e||n<e)&&(e=n)}),e}function checkLineIntersection(o,e,t,n){if(o&&e&&t&&n){var i=e.plotX-o.plotX,e=e.plotY-o.plotY,s=n.plotX-t.plotX,n=n.plotY-t.plotY,r=o.plotX-t.plotX,t=o.plotY-t.plotY,p=(-e*r+i*t)/(-s*e+i*n),t=(s*t-n*r)/(-s*e+i*n);if(0<=p&&p<=1&&0<=t&&t<=1)return{plotX:o.plotX+t*i,plotY:o.plotY+t*e}}}function drawSenkouSpan(o){const e=o.indicator;e.points=o.points,e.nextPoints=o.nextPoints,e.color=o.color,e.options=merge(o.options.senkouSpan.styles,o.gap),e.graph=o.graph,e.fillGraph=!0,SeriesRegistry.seriesTypes.sma.prototype.drawGraph.call(e)}function ichimokuAverages(){const t=[];let n;return[].forEach.call(arguments,function(o,e){t.push(ApproximationRegistry.average(o)),n=!n&&void 0===t[e]}),n?void 0:t}class IKHIndicator extends SMAIndicator{constructor(){super(...arguments),this.data=[],this.options={},this.points=[],this.graphCollection=[]}init(){super.init.apply(this,arguments),this.options=merge({tenkanLine:{styles:{lineColor:this.color}},kijunLine:{styles:{lineColor:this.color}},chikouLine:{styles:{lineColor:this.color}},senkouSpanA:{styles:{lineColor:this.color,fill:color(this.color).setOpacity(.5).get()}},senkouSpanB:{styles:{lineColor:this.color,fill:color(this.color).setOpacity(.5).get()}},senkouSpan:{styles:{fill:color(this.color).setOpacity(.2).get()}}},this.options)}toYData(o){return[o.tenkanSen,o.kijunSen,o.chikouSpan,o.senkouSpanA,o.senkouSpanB]}translate(){var o=this;SeriesRegistry.seriesTypes.sma.prototype.translate.apply(o);for(const t of o.points)for(const n of o.pointArrayMap){var e=t[n];isNumber(e)&&(t["plot"+n]=o.yAxis.toPixels(e,!0),t.plotY=t["plot"+n],t.tooltipPos=[t.plotX,t["plot"+n]],t.isNull=!1)}}drawGraph(){const t=this,o=t.points,n=t.options,e=t.graph,i=t.color,s={options:{gapSize:n.gapSize}},r=t.pointArrayMap.length,p=[[],[],[],[],[],[]],a={tenkanLine:p[0],kijunLine:p[1],chikouLine:p[2],senkouSpanA:p[3],senkouSpanB:p[4],senkouSpan:p[5]},l=[],h=t.options.senkouSpan,c=h.color||h.styles.fill,u=h.negativeColor,g=[[],[]],S=[[],[]];let k=o.length,d=0,f,y,m,A,v,x,C,Y,P,I,L,B,w;for(t.ikhMap=a;k--;){for(y=o[k],m=0;m<r;m++)f=t.pointArrayMap[m],defined(y[f])&&p[m].push({plotX:y.plotX,plotY:y["plot"+f],isNull:!1});var N,R;u&&k!==o.length-1&&(N=a.senkouSpanB.length-1,(R=checkLineIntersection(a.senkouSpanA[N-1],a.senkouSpanA[N],a.senkouSpanB[N-1],a.senkouSpanB[N]))&&(R={plotX:R.plotX,plotY:R.plotY,isNull:!1,intersectPoint:!0},a.senkouSpanA.splice(N,0,R),a.senkouSpanB.splice(N,0,R),l.push(N)))}if(objectEach(a,(o,e)=>{n[e]&&"senkouSpan"!==e&&(t.points=p[d],t.options=merge(n[e].styles,s),t.graph=t["graph"+e],t.fillGraph=!1,t.color=i,SeriesRegistry.seriesTypes.sma.prototype.drawGraph.call(t),t["graph"+e]=t.graph),d++}),t.graphCollection)for(const G of t.graphCollection)t[G].destroy(),delete t[G];if(t.graphCollection=[],u&&a.senkouSpanA[0]&&a.senkouSpanB[0]){for(l.unshift(0),l.push(a.senkouSpanA.length-1),B=0;B<l.length-1;B++)if(A=l[B],v=l[B+1],x=a.senkouSpanB.slice(A,v+1),C=a.senkouSpanA.slice(A,v+1),1<=Math.floor(x.length/2)){var b=Math.floor(x.length/2);if(x[b].plotY===C[b].plotY){for(Y=0,P=0,w=0;w<x.length;w++)Y+=x[w].plotY,P+=C[w].plotY;L=Y>P?0:1,g[L]=g[L].concat(x),S[L]=S[L].concat(C)}else L=x[b].plotY>C[b].plotY?0:1,g[L]=g[L].concat(x),S[L]=S[L].concat(C)}else L=x[0].plotY>C[0].plotY?0:1,g[L]=g[L].concat(x),S[L]=S[L].concat(C);["graphsenkouSpanColor","graphsenkouSpanNegativeColor"].forEach(function(o,e){g[e].length&&S[e].length&&(I=0===e?c:u,drawSenkouSpan({indicator:t,points:g[e],nextPoints:S[e],color:I,options:n,gap:s,graph:t[o]}),t[o]=t.graph,t.graphCollection.push(o))})}else drawSenkouSpan({indicator:t,points:a.senkouSpanB,nextPoints:a.senkouSpanA,color:c,options:n,gap:s,graph:t.graphsenkouSpan}),t.graphsenkouSpan=t.graph;delete t.nextPoints,delete t.fillGraph,t.points=o,t.options=n,t.graph=e,t.color=i}getGraphPath(o){var e=this;let t=[],n,i;if(o=o||this.points,e.fillGraph&&e.nextPoints){if((n=SeriesRegistry.seriesTypes.sma.prototype.getGraphPath.call(e,e.nextPoints))&&n.length){n[0][0]="L",t=SeriesRegistry.seriesTypes.sma.prototype.getGraphPath.call(e,o);for(let o=(i=n.slice(0,t.length)).length-1;0<=o;o--)t.push(i[o])}}else t=SeriesRegistry.seriesTypes.sma.prototype.getGraphPath.apply(e,arguments);return t}getValues(o,e){const t=e.period,n=e.periodTenkan,i=e.periodSenkouSpanB,s=o.xData,r=o.yData,p=o.xAxis,a=r&&r.length||0,l=getClosestPointRange(p),h=[],c=[];let u,g,S,k,d,f,y,m,A,v;if(!(s.length<=t)&&isArray(r[0])&&4===r[0].length){var x=s[0]-t*l;for(d=0;d<t;d++)c.push(x+d*l);for(d=0;d<a;d++)d>=n&&(g=highlowLevel(r.slice(d-n,d)),f=(g.high+g.low)/2),d>=t&&(S=highlowLevel(r.slice(d-t,d)),y=(S.high+S.low)/2,A=(f+y)/2),d>=i&&(k=highlowLevel(r.slice(d-i,d)),v=(k.high+k.low)/2),m=r[d][3],u=s[d],void 0===h[d]&&(h[d]=[]),void 0===h[d+t-1]&&(h[d+t-1]=[]),h[d+t-1][0]=f,h[d+t-1][1]=y,(h[d+t-1][2]=void 0)===h[d+1]&&(h[d+1]=[]),h[d+1][2]=m,d<=t&&(h[d+t-1][3]=void 0,h[d+t-1][4]=void 0),void 0===h[d+2*t-2]&&(h[d+2*t-2]=[]),h[d+2*t-2][3]=A,h[d+2*t-2][4]=v,c.push(u);for(d=1;d<=t;d++)c.push(u+d*l);return{values:h,xData:c,yData:h}}}}IKHIndicator.defaultOptions=merge(SMAIndicator.defaultOptions,{params:{index:void 0,period:26,periodTenkan:9,periodSenkouSpanB:52},marker:{enabled:!1},tooltip:{pointFormat:'<span style="color:{point.color}">‚óè</span> <b> {series.name}</b><br/>TENKAN SEN: {point.tenkanSen:.3f}<br/>KIJUN SEN: {point.kijunSen:.3f}<br/>CHIKOU SPAN: {point.chikouSpan:.3f}<br/>SENKOU SPAN A: {point.senkouSpanA:.3f}<br/>SENKOU SPAN B: {point.senkouSpanB:.3f}<br/>'},tenkanLine:{styles:{lineWidth:1,lineColor:void 0}},kijunLine:{styles:{lineWidth:1,lineColor:void 0}},chikouLine:{styles:{lineWidth:1,lineColor:void 0}},senkouSpanA:{styles:{lineWidth:1,lineColor:void 0}},senkouSpanB:{styles:{lineWidth:1,lineColor:void 0}},senkouSpan:{styles:{fill:"rgba(255, 0, 0, 0.5)"}},dataGrouping:{approximation:"ichimoku-averages"}}),extend(IKHIndicator.prototype,{pointArrayMap:["tenkanSen","kijunSen","chikouSpan","senkouSpanA","senkouSpanB"],pointValKey:"tenkanSen",nameComponents:["periodSenkouSpanB","period","periodTenkan"]}),ApproximationRegistry["ichimoku-averages"]=ichimokuAverages,SeriesRegistry.registerSeriesType("ikh",IKHIndicator);export default IKHIndicator;