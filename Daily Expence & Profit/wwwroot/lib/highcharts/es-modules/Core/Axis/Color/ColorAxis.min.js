"use strict";import Axis from"../Axis.js";import Color from"../../Color/Color.js";const color=Color["parse"];import ColorAxisComposition from"./ColorAxisComposition.js";import ColorAxisDefaults from"./ColorAxisDefaults.js";import LegendSymbol from"../../Legend/LegendSymbol.js";import SeriesRegistry from"../../Series/SeriesRegistry.js";const Series=SeriesRegistry["series"];import U from"../../Utilities.js";const{extend,isNumber,merge,pick}=U;class ColorAxis extends Axis{static compose(e,t,s,o){ColorAxisComposition.compose(ColorAxis,e,t,s,o)}constructor(e,t){super(e,t),this.beforePadding=!1,this.chart=void 0,this.coll="colorAxis",this.dataClasses=void 0,this.options=void 0,this.stops=void 0,this.visible=!0,this.init(e,t)}init(e,t){var s=this,o=e.options.legend||{},i=t.layout?"vertical"!==t.layout:"vertical"!==o.layout,r=t.visible,o=merge(ColorAxis.defaultColorAxisOptions,t,{showEmpty:!1,title:null,visible:o.enabled&&!1!==r});s.coll="colorAxis",s.side=t.side||i?2:1,s.reversed=t.reversed||!i,s.opposite=!i,super.init(e,o),s.userOptions.visible=r,t.dataClasses&&s.initDataClasses(t),s.initStops(),s.horiz=i,s.zoomEnabled=!1}initDataClasses(e){const t=this,o=t.chart,s=t.legendItem=t.legendItem||{},i=e.dataClasses.length,r=t.options;let l,a=0,n=o.options.chart.colorCount;t.dataClasses=l=[],s.labels=[],(e.dataClasses||[]).forEach(function(e,t){var s;e=merge(e),l.push(e),!o.styledMode&&e.color||("category"===r.dataClassColor?(o.styledMode||(s=o.options.colors,n=s.length,e.color=s[a]),e.colorIndex=a,++a===n&&(a=0)):e.color=color(r.minColor).tweenTo(color(r.maxColor),i<2?.5:t/(i-1)))})}hasData(){return!!(this.tickPositions||[]).length}setTickPositions(){if(!this.dataClasses)return super.setTickPositions()}initStops(){var e=this;e.stops=e.options.stops||[[0,e.options.minColor],[1,e.options.maxColor]],e.stops.forEach(function(e){e.color=color(e[1])})}setOptions(e){super.setOptions(e),this.options.crosshair=this.options.marker}setAxisSize(){var e=this;const t=e.legendItem&&e.legendItem.symbol;var s,o,i,r,e=e.chart,l=e.options.legend||{};t?(this.left=s=t.attr("x"),this.top=o=t.attr("y"),this.width=i=t.attr("width"),this.height=r=t.attr("height"),this.right=e.chartWidth-s-i,this.bottom=e.chartHeight-o-r,this.len=this.horiz?i:r,this.pos=this.horiz?s:o):this.len=(this.horiz?l.symbolWidth:l.symbolHeight)||ColorAxis.defaultLegendLength}normalizedValue(e){var t=this;return t.logarithmic&&(e=t.logarithmic.log2lin(e)),1-(t.max-e)/(t.max-t.min||1)}toColor(e,t){var s=this,o=s.dataClasses,i=s.stops;let r,l,a,n,d,h;if(o){for(h=o.length;h--;)if(d=o[h],l=d.from,a=d.to,(void 0===l||e>=l)&&(void 0===a||e<=a)){n=d.color,t&&(t.dataClass=h,t.colorIndex=d.colorIndex);break}}else{for(r=s.normalizedValue(e),h=i.length;h--&&!(r>i[h][0]););l=i[h]||i[h+1],a=i[h+1]||l,r=1-(a[0]-r)/(a[0]-l[0]||1),n=l.color.tweenTo(a.color,r)}return n}getOffset(){var e=this,t=e.legendItem&&e.legendItem.group,s=e.chart.axisOffset[e.side];if(t){e.axisParent=t,super.getOffset();const o=this.chart.legend;o.allItems.forEach(function(e){e instanceof ColorAxis&&e.drawLegendSymbol(o,e)}),o.render(),this.chart.getMargins(!0),e.added||(e.added=!0,e.labelLeft=0,e.labelRight=e.width),e.chart.axisOffset[e.side]=s}}setLegendColor(){var e=this.horiz,t=this.reversed,s=t?1:0,t=t?0:1,e=e?[s,0,t,0]:[0,t,0,s];this.legendColor={linearGradient:{x1:e[0],y1:e[1],x2:e[2],y2:e[3]},stops:this.stops}}drawLegendSymbol(e,t){const s=t.legendItem||{},o=e.padding,i=e.options,r=this.options.labels,l=pick(i.itemDistance,10),a=this.horiz,n=pick(i.symbolWidth,a?ColorAxis.defaultLegendLength:12),d=pick(i.symbolHeight,a?12:ColorAxis.defaultLegendLength),h=pick(i.labelPadding,a?16:30);this.setLegendColor(),s.symbol||(s.symbol=this.chart.renderer.symbol("roundedRect",0,e.baseline-11,n,d,{r:null!=(t=i.symbolRadius)?t:3}).attr({zIndex:1}).add(s.group)),s.labelWidth=n+o+(a?l:pick(r.x,r.distance)+this.maxLabelLength),s.labelHeight=d+o+(a?h:0)}setState(t){this.series.forEach(function(e){e.setState(t)})}setVisible(){}getSeriesExtremes(){var e,t=this.series;let s,o,i,r,l,a,n=t.length,d,h;for(this.dataMin=1/0,this.dataMax=-1/0;n--;){if(o=(a=t[n]).colorKey=pick(a.options.colorKey,a.colorKey,a.pointValKey,a.zoneAxis,"y"),r=a.pointArrayMap,l=a[o+"Min"]&&a[o+"Max"],a[o+"Data"])s=a[o+"Data"];else if(r){if(s=[],i=r.indexOf(o),d=a.yData,0<=i&&d)for(h=0;h<d.length;h++)s.push(pick(d[h][i],d[h]))}else s=a.yData;l?(a.minColorValue=a[o+"Min"],a.maxColorValue=a[o+"Max"]):(e=Series.prototype.getExtremes.call(a,s),a.minColorValue=e.dataMin,a.maxColorValue=e.dataMax),void 0!==a.minColorValue&&(this.dataMin=Math.min(this.dataMin,a.minColorValue),this.dataMax=Math.max(this.dataMax,a.maxColorValue)),l||Series.prototype.applyExtremes.call(a)}}drawCrosshair(e,t){var s=this,o=s.legendItem||{},i=t&&t.plotX,r=t&&t.plotY,l=s.pos,a=s.len;let n;t&&((n=s.toPixels(t.getNestedProperty(t.series.colorKey)))<l?n=l-2:n>l+a&&(n=l+a+2),t.plotX=n,t.plotY=s.len-n,super.drawCrosshair(e,t),t.plotX=i,t.plotY=r,s.cross&&!s.cross.addedToColorAxis&&o.group&&(s.cross.addClass("highcharts-coloraxis-marker").add(o.group),s.cross.addedToColorAxis=!0,s.chart.styledMode||"object"!=typeof s.crosshair||s.cross.attr({fill:s.crosshair.color})))}getPlotLinePath(e){var t=this.left,s=e.translatedValue,o=this.top;return isNumber(s)?this.horiz?[["M",s-4,o-6],["L",s+4,o-6],["L",s,o],["Z"]]:[["M",t,s],["L",t-6,s+6],["L",t-6,s-6],["Z"]]:super.getPlotLinePath(e)}update(e,t){const s=this,o=s.chart,i=o.legend;this.series.forEach(e=>{e.isDirtyData=!0}),(e.dataClasses&&i.allItems||s.dataClasses)&&s.destroyItems(),super.update(e,t),s.legendItem&&s.legendItem.label&&(s.setLegendColor(),i.colorizeItem(this,!0))}destroyItems(){const e=this.chart,t=this.legendItem||{};if(t.label)e.legend.destroyItem(this);else if(t.labels)for(const s of t.labels)e.legend.destroyItem(s);e.isDirtyLegend=!0}destroy(){this.chart.isDirtyLegend=!0,this.destroyItems(),super.destroy(...[].slice.call(arguments))}remove(e){this.destroyItems(),super.remove(e)}getDataClassLegendSymbols(){const l=this,a=l.chart,n=l.legendItem&&l.legendItem.labels||[],e=a.options.legend,d=pick(e.valueDecimals,-1),h=pick(e.valueSuffix,""),c=s=>l.series.reduce((e,t)=>(e.push(...t.points.filter(e=>e.dataClass===s)),e),[]);let p;return n.length||l.dataClasses.forEach((e,s)=>{const t=e.from,o=e.to,i=a["numberFormatter"];let r=!0;p="",void 0===t?p="< ":void 0===o&&(p="> "),void 0!==t&&(p+=i(t,d)+h),void 0!==t&&void 0!==o&&(p+=" - "),void 0!==o&&(p+=i(o,d)+h),n.push(extend({chart:a,name:p,options:{},drawLegendSymbol:LegendSymbol.rectangle,visible:!0,isDataClass:!0,setState:e=>{for(const t of c(s))t.setState(e)},setVisible:function(){this.visible=r=l.visible=!r;for(const e of c(s))e.setVisible(r);a.legend.colorizeItem(this,r)}},e))}),n}}ColorAxis.defaultColorAxisOptions=ColorAxisDefaults,ColorAxis.defaultLegendLength=200,ColorAxis.keepProps=["legendItem"],Array.prototype.push.apply(Axis.keepProps,ColorAxis.keepProps);export default ColorAxis;