"use strict";import Color from"../../Color/Color.js";const color=Color["parse"];import U from"../../Utilities.js";const{addEvent,extend,merge,pick,splat}=U;var ColorAxisComposition;!function(o){const c=[];let a;function h(){const o=this.options;this.colorAxis=[],o.colorAxis&&(o.colorAxis=splat(o.colorAxis),o.colorAxis.forEach((o,t)=>{o.index=t,new a(this,o)}))}function p(t){const o=this.chart.colorAxis||[],i=o=>{o=t.allItems.indexOf(o);-1!==o&&(this.destroyItem(t.allItems[o]),t.allItems.splice(o,1))};let s=[],e,n;for(o.forEach(function(o){(e=o.options)&&e.showInLegend&&(e.dataClasses&&e.visible?s=s.concat(o.getDataClassLegendSymbols()):e.visible&&s.push(o),o.series.forEach(function(o){o.options.showInLegend&&!e.dataClasses||("point"===o.options.legendType?o.points.forEach(function(o){i(o)}):i(o))}))}),n=s.length;n--;)t.allItems.unshift(s[n])}function d(o){o.visible&&o.item.legendColor&&o.item.legendItem.symbol.attr({fill:o.item.legendColor})}function f(){const o=this.chart.colorAxis;o&&o.forEach(function(o){o.update({},arguments[2])})}function u(){(this.chart.colorAxis&&this.chart.colorAxis.length||this.colorAttribs)&&this.translateColors()}function x(){const o=this.axisTypes;o?-1===o.indexOf("colorAxis")&&o.push("colorAxis"):this.axisTypes=["colorAxis"]}function m(o){const t=this,i=o?"show":"hide";t.visible=t.options.visible=Boolean(o),["graphic","dataLabel"].forEach(function(o){t[o]&&t[o][i]()}),this.series.buildKDTree()}function A(){const i=this,o=this.data.length?this.data:this.points,s=this.options.nullColor,e=this.colorAxis,n=this.colorKey;o.forEach(o=>{var t=o.getNestedProperty(n),t=o.options.color||(o.isNull||null===o.value?s:e&&void 0!==t?e.toColor(t,o):o.color||i.color);t&&o.color!==t&&(o.color=t,"point"===i.options.legendType&&o.legendItem&&o.legendItem.label&&i.chart.legend.colorizeItem(o,o.visible))})}function C(){this.elem.attr("fill",color(this.start).tweenTo(color(this.end),this.pos),void 0,!0)}function g(){this.elem.attr("stroke",color(this.start).tweenTo(color(this.end),this.pos),void 0,!0)}o.compose=function(o,t,i,s,e){if(a=a||o,U.pushUnique(c,t)){const n=t.prototype;n.collectionsWithUpdate.push("colorAxis"),n.collectionsWithInit.colorAxis=[n.addColorAxis],addEvent(t,"afterGetAxes",h);{o=t;const r=o.prototype.createAxis;o.prototype.createAxis=function(o,t){if("colorAxis"!==o)return r.apply(this,arguments);o=new a(this,merge(t.axis,{index:this[o].length,isX:!1}));return this.isDirtyLegend=!0,this.axes.forEach(function(o){o.series=[]}),this.series.forEach(function(o){o.bindAxes(),o.isDirtyData=!0}),pick(t.redraw,!0)&&this.redraw(t.animation),o}}}if(U.pushUnique(c,i)){const l=i.prototype;l.fillSetter=C,l.strokeSetter=g}U.pushUnique(c,s)&&(addEvent(s,"afterGetAllItems",p),addEvent(s,"afterColorizeItem",d),addEvent(s,"afterUpdate",f)),U.pushUnique(c,e)&&(extend(e.prototype,{optionalAxis:"colorAxis",translateColors:A}),extend(e.prototype.pointClass.prototype,{setVisible:m}),addEvent(e,"afterTranslate",u,{order:1}),addEvent(e,"bindAxes",x))},o.pointSetVisible=m}(ColorAxisComposition=ColorAxisComposition||{});export default ColorAxisComposition;