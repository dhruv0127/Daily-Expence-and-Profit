"use strict";import A from"../../Animation/AnimationUtilities.js";const getDeferredAnimation=A["getDeferredAnimation"];import Axis from"../Axis.js";import SeriesRegistry from"../../Series/SeriesRegistry.js";const{prototype:seriesProto}=SeriesRegistry["series"];import StackItem from"./StackItem.js";import U from"../../Utilities.js";const{addEvent,correctFloat,defined,destroyObjectProperties,fireEvent,isArray,isNumber,objectEach,pick}=U;function chartGetStacks(){const e=this,i=e.inverted;e.yAxis.forEach(t=>{t.stacking&&t.stacking.stacks&&t.hasVisibleSeries&&(t.stacking.oldStacks=t.stacking.stacks)}),e.series.forEach(t=>{const s=t.xAxis&&t.xAxis.options||{};!t.options.stacking||!0!==t.visible&&!1!==e.options.chart.ignoreHiddenSeries||(t.stackKey=[t.type,pick(t.options.stack,""),i?s.top:s.left,i?s.height:s.width].join(","))})}function onAxisDestroy(){const t=this.stacking;if(t){const e=t.stacks;objectEach(e,function(t,s){destroyObjectProperties(t),e[s]=null}),t&&t.stackTotalGroup&&t.stackTotalGroup.destroy()}}function onAxisInit(){"yAxis"!==this.coll||this.stacking||(this.stacking=new AxisAdditions(this))}function seriesGetStackIndicator(t,s,e,i){return!defined(t)||t.x!==s||i&&t.stackKey!==i?t={x:s,index:0,key:i,stackKey:i}:t.index++,t.key=[e,s,t.index].join(","),t}function seriesModifyStacks(){const c=this,t=c.yAxis,s=c.stackKey,a=t.stacking.stacks,n=c.processedXData,e=c.options.stacking,r=c[e+"Stacker"];let k;r&&[s,"-"+s].forEach(t=>{let s=n.length,e,i,o;for(;s--;)e=n[s],k=c.getStackIndicator(k,e,c.index,t),(o=(i=a[t]&&a[t][e])&&i.points[k.key])&&r.call(c,o,i,s)})}function seriesPercentStacker(t,s,e){s=s.total?100/s.total:0;t[0]=correctFloat(t[0]*s),t[1]=correctFloat(t[1]*s),this.stackedYData[e]=t[1]}function seriesSetGroupedPoints(){const e=this.yAxis.stacking;this.options.centerInCategory&&(this.is("column")||this.is("columnrange"))&&!this.options.stacking&&1<this.chart.series.length?seriesProto.setStackedPoints.call(this,"group"):e&&objectEach(e.stacks,(t,s)=>{"group"===s.slice(-5)&&(objectEach(t,t=>t.destroy()),delete e.stacks[s])})}function seriesSetStackedPoints(k){var l=this.chart,d=k||this.options.stacking;if(d&&(!0===this.visible||!1===l.options.chart.ignoreHiddenSeries)){const h=this,u=h.processedXData,p=h.processedYData,g=[],S=p.length,f=h.options,y=f.threshold,x=pick(f.startFromThreshold&&y,0),m=f.stack,A=k?h.type+","+d:h.stackKey,b="-"+A,v=h.negStacks,j="group"===d?l.yAxis[0]:h.yAxis,E=j.stacking.stacks,P=j.stacking.oldStacks;let t,s,e,i,o,c,a,n,r;for(j.stacking.stacksTouched+=1,a=0;a<S;a++)n=u[a],r=p[a],c=(t=h.getStackIndicator(t,n,h.index)).key,o=(s=v&&r<(x?0:y))?b:A,E[o]||(E[o]={}),E[o][n]||(P[o]&&P[o][n]?(E[o][n]=P[o][n],E[o][n].total=null):E[o][n]=new StackItem(j,j.options.stackLabels,!!s,n,m)),e=E[o][n],null!==r?(e.points[c]=e.points[h.index]=[pick(e.cumulative,x)],defined(e.cumulative)||(e.base=c),e.touched=j.stacking.stacksTouched,0<t.index&&!1===h.singleStacks&&(e.points[c][0]=e.points[h.index+","+n+",0"][0])):e.points[c]=e.points[h.index]=null,"percent"===d?(i=s?A:b,v&&E[i]&&E[i][n]?(i=E[i][n],e.total=i.total=Math.max(i.total,e.total)+Math.abs(r)||0):e.total=correctFloat(e.total+(Math.abs(r)||0))):"group"===d?null!==(r=isArray(r)?r[0]:r)&&(e.total=(e.total||0)+1):e.total=correctFloat(e.total+(r||0)),e.cumulative="group"===d?(e.total||1)-1:correctFloat(pick(e.cumulative,x)+(r||0)),null!==r&&(e.points[c].push(e.cumulative),g[a]=e.cumulative,e.hasValidPoints=!0);"percent"===d&&(j.stacking.usePercentage=!0),"group"!==d&&(this.stackedYData=g),j.stacking.oldStacks={}}}class AxisAdditions{constructor(t){this.oldStacks={},this.stacks={},this.stacksTouched=0,this.axis=t}buildStacks(){var t=this.axis;const s=t.series;var e=t.options.reversedStacks,i=s.length;let o,c;for(this.usePercentage=!1,c=i;c--;)(o=s[e?c:i-c-1]).setStackedPoints(),o.setGroupedPoints();for(c=0;c<i;c++)s[c].modifyStacks();fireEvent(t,"afterBuildStacks")}cleanStacks(){let t;this.oldStacks&&(t=this.stacks=this.oldStacks),objectEach(t,function(t){objectEach(t,function(t){t.cumulative=t.total})})}resetStacks(){objectEach(this.stacks,e=>{objectEach(e,(t,s)=>{isNumber(t.touched)&&t.touched<this.stacksTouched?(t.destroy(),delete e[s]):(t.total=null,t.cumulative=null)})})}renderStackTotals(){const t=this.axis,s=t.chart,e=s.renderer,i=this.stacks,o=t.options.stackLabels&&t.options.stackLabels.animation,c=getDeferredAnimation(s,o||!1),a=this.stackTotalGroup=this.stackTotalGroup||e.g("stack-labels").attr({zIndex:6,opacity:0}).add();a.translate(s.plotLeft,s.plotTop),objectEach(i,function(t){objectEach(t,function(t){t.render(a)})}),a.animate({opacity:1},c)}}var StackingAxis;!function(t){const c=[];t.compose=function(t,s,e){if(U.pushUnique(c,t)&&(addEvent(t,"init",onAxisInit),addEvent(t,"destroy",onAxisDestroy)),U.pushUnique(c,s)){const i=s.prototype;i.getStacks=chartGetStacks}if(U.pushUnique(c,e)){const o=e.prototype;o.getStackIndicator=seriesGetStackIndicator,o.modifyStacks=seriesModifyStacks,o.percentStacker=seriesPercentStacker,o.setGroupedPoints=seriesSetGroupedPoints,o.setStackedPoints=seriesSetStackedPoints}}}(StackingAxis=StackingAxis||{});export default StackingAxis;