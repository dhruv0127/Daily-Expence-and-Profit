"use strict";import F from"../FormatUtilities.js";import H from"../Globals.js";const deg2rad=H["deg2rad"];import U from"../Utilities.js";const{clamp,correctFloat,defined,destroyObjectProperties,extend,fireEvent,isNumber,merge,objectEach,pick}=U;class Tick{constructor(t,e,i,a,s){this.isNew=!0,this.isNewLabel=!0,this.axis=t,this.pos=e,this.type=i||"",this.parameters=s||{},this.tickmarkOffset=this.parameters.tickmarkOffset,this.options=this.parameters.options,fireEvent(this,"init"),i||a||this.addLabel()}addLabel(){const t=this,e=t.axis,i=e.options,a=e.chart,s=e.categories,r=e.logarithmic,o=e.names,l=t.pos,d=pick(t.options&&t.options.labels,i.labels),n=e.tickPositions,h=l===n[0],c=l===n[n.length-1],b=(!d.step||1===d.step)&&1===e.tickInterval,m=n.info;let p=t.label,f,L,x,k=this.parameters.category||(s?pick(s[l],o[l],l):l);r&&isNumber(k)&&(k=correctFloat(r.lin2log(k))),e.dateTime&&(m?(L=a.time.resolveDTLFormat(i.dateTimeLabelFormats[!i.grid&&m.higherRanks[l]||m.unitName]),f=L.main):isNumber(k)&&(f=e.dateTime.getXDateFormat(k,i.dateTimeLabelFormats||{}))),t.isFirst=h,t.isLast=c;const g={axis:e,chart:a,dateTimeLabelFormat:f,isFirst:h,isLast:c,pos:l,tick:t,tickPositionInfo:m,value:k},y=(fireEvent(this,"labelFormat",g),t=>d.formatter?d.formatter.call(t,t):d.format?(t.text=e.defaultLabelFormatter.call(t,t),F.format(d.format,t,a)):e.defaultLabelFormatter.call(t,t));var v=y.call(g,g);const u=L&&L.list;u?t.shortenLabel=function(){for(x=0;x<u.length;x++)if(extend(g,{dateTimeLabelFormat:u[x]}),p.attr({text:y.call(g,g)}),p.getBBox().width<e.getSlotWidth(t)-2*d.padding)return;p.attr({text:""})}:t.shortenLabel=void 0,b&&e._addedPlotLB&&t.moveLabel(v,d),defined(p)||t.movedLabel?p&&p.textStr!==v&&!b&&(!p.textWidth||d.style.width||p.styles.width||p.css({width:null}),p.attr({text:v}),p.textPxLength=p.getBBox().width):(t.label=p=t.createLabel({x:0,y:0},v,d),t.rotation=0)}createLabel(t,e,i){const a=this.axis,s=a.chart,r=defined(e)&&i.enabled?s.renderer.text(e,t.x,t.y,i.useHTML).add(a.labelGroup):null;return r&&(s.styledMode||r.css(merge(i.style)),r.textPxLength=r.getBBox().width),r}destroy(){destroyObjectProperties(this,this.axis)}getPosition(t,e,i,a){const s=this.axis,r=s.chart,o=a&&r.oldChartHeight||r.chartHeight,l={x:t?correctFloat(s.translate(e+i,void 0,void 0,a)+s.transB):s.left+s.offset+(s.opposite?(a&&r.oldChartWidth||r.chartWidth)-s.right-s.left:0),y:t?o-s.bottom+s.offset-(s.opposite?s.height:0):correctFloat(o-s.translate(e+i,void 0,void 0,a)-s.transB)};return l.y=clamp(l.y,-1e5,1e5),fireEvent(this,"afterGetPosition",{pos:l}),l}getLabelPosition(t,e,i,a,s,r,o,l){const d=this.axis,n=d.transA,h=(d.isLinked&&d.linkedParent?d.linkedParent:d).reversed,c=d.staggerLines,b=d.tickRotCorr||{x:0,y:0},m=a||d.reserveSpaceDefault?0:-d.labelOffset*("center"===d.labelAlign?.5:1),p=s.distance,f={};let L,x;return L=0===d.side?i.rotation?-p:-i.getBBox().height:2===d.side?b.y+p:Math.cos(i.rotation*deg2rad)*(b.y-i.getBBox(!1,0).height/2),defined(s.y)&&(L=0===d.side&&d.horiz?s.y+L:s.y),t=t+pick(s.x,[0,1,0,-1][d.side]*p)+m+b.x-(r&&a?r*n*(h?-1:1):0),e=e+L-(r&&!a?r*n*(h?1:-1):0),c&&(x=o/(l||1)%c,e+=(x=d.opposite?c-x-1:x)*(d.labelOffset/c)),f.x=t,f.y=Math.round(e),fireEvent(this,"afterGetLabelPosition",{pos:f,tickmarkOffset:r,index:o}),f}getLabelSize(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0}getMarkPath(t,e,i,a,s,r){return r.crispLine([["M",t,e],["L",t+(s?0:-i),e+(s?i:0)]],a)}handleOverflow(t){const e=this.axis,i=e.options.labels,a=t.x,s=e.chart.chartWidth,r=e.chart.spacing,o=pick(e.labelLeft,Math.min(e.pos,r[3])),l=pick(e.labelRight,Math.max(e.isRadial?0:e.pos+e.len,s-r[1])),d=this.label,n=this.rotation,h={left:0,center:.5,right:1}[e.labelAlign||d.attr("align")],c=d.getBBox().width,b=e.getSlotWidth(this),m=h,p={};let f=b,L=1,x;n||"justify"!==i.overflow?n<0&&a-h*c<o?x=Math.round(a/Math.cos(n*deg2rad)-o):0<n&&l<a+h*c&&(x=Math.round((s-a)/Math.cos(n*deg2rad))):(a-h*c<o?f=t.x+f*(1-h)-o:l<a+(1-h)*c&&(f=l-t.x+f*h,L=-1),(f=Math.min(b,f))<b&&"center"===e.labelAlign&&(t.x+=L*(b-f-m*(b-Math.min(c,f)))),(c>f||e.autoRotation&&(d.styles||{}).width)&&(x=f)),x&&(this.shortenLabel?this.shortenLabel():(p.width=Math.floor(x)+"px",(i.style||{}).textOverflow||(p.textOverflow="ellipsis"),d.css(p)))}moveLabel(e,t){const i=this,a=i.label,s=i.axis;let r=!1,o;a&&a.textStr===e?(i.movedLabel=a,r=!0,delete i.label):objectEach(s.ticks,function(t){r||t.isNew||t===i||!t.label||t.label.textStr!==e||(i.movedLabel=t.label,r=!0,t.labelPos=i.movedLabel.xy,delete t.label)}),r||!i.labelPos&&!a||(o=i.labelPos||a.xy,i.movedLabel=i.createLabel(o,e,t),i.movedLabel&&i.movedLabel.attr({opacity:0}))}render(t,e,i){var a=this,s=a.axis,r=s.horiz,o=a.pos,l=pick(a.tickmarkOffset,s.tickmarkOffset),o=a.getPosition(r,o,l,e),l=o.x,d=o.y,l=r&&l===s.pos+s.len||!r&&d===s.pos?-1:1,r=pick(i,a.label&&a.label.newOpacity,1);i=pick(i,1),this.isActive=!0,this.renderGridLine(e,i,l),this.renderMark(o,i,l),this.renderLabel(o,e,r,t),a.isNew=!1,fireEvent(this,"afterRender")}renderGridLine(t,e,i){const a=this,s=a.axis,r=s.options,o={},l=a.pos,d=a.type,n=pick(a.tickmarkOffset,s.tickmarkOffset),h=s.chart.renderer;let c=a.gridLine,b,m=r.gridLineWidth,p=r.gridLineColor,f=r.gridLineDashStyle;"minor"===a.type&&(m=r.minorGridLineWidth,p=r.minorGridLineColor,f=r.minorGridLineDashStyle),c||(s.chart.styledMode||(o.stroke=p,o["stroke-width"]=m||0,o.dashstyle=f),d||(o.zIndex=1),t&&(e=0),a.gridLine=c=h.path().attr(o).addClass("highcharts-"+(d?d+"-":"")+"grid-line").add(s.gridGroup)),c&&(b=s.getPlotLinePath({value:l+n,lineWidth:c.strokeWidth()*i,force:"pass",old:t,acrossPanes:!1}))&&c[t||a.isNew?"attr":"animate"]({d:b,opacity:e})}renderMark(t,e,i){const a=this,s=a.axis,r=s.options,o=s.chart.renderer,l=a.type,d=s.tickSize(l?l+"Tick":"tick"),n=t.x,h=t.y,c=pick(r["minor"!==l?"tickWidth":"minorTickWidth"],!l&&s.isXAxis?1:0),b=r["minor"!==l?"tickColor":"minorTickColor"];let m=a.mark;t=!m;d&&(s.opposite&&(d[0]=-d[0]),m||(a.mark=m=o.path().addClass("highcharts-"+(l?l+"-":"")+"tick").add(s.axisGroup),s.chart.styledMode||m.attr({stroke:b,"stroke-width":c})),m[t?"attr":"animate"]({d:a.getMarkPath(n,h,d[0],m.strokeWidth()*i,s.horiz,o),opacity:e}))}renderLabel(t,e,i,a){const s=this,r=s.axis,o=r.horiz,l=r.options,d=s.label,n=l.labels,h=n.step,c=pick(s.tickmarkOffset,r.tickmarkOffset),b=t.x,m=t.y;let p=!0;d&&isNumber(b)&&(d.xy=t=s.getLabelPosition(b,m,d,o,n,c,a,h),s.isFirst&&!s.isLast&&!l.showFirstLabel||s.isLast&&!s.isFirst&&!l.showLastLabel?p=!1:!o||n.step||n.rotation||e||0===i||s.handleOverflow(t),(p=h&&a%h?!1:p)&&isNumber(t.y)?(t.opacity=i,d[s.isNewLabel?"attr":"animate"](t).show(!0),s.isNewLabel=!1):(d.hide(),s.isNewLabel=!0))}replaceMovedLabel(){const t=this,e=t.label,i=t.axis;e&&!t.isNew&&(e.animate({opacity:0},void 0,e.destroy),delete t.label),i.isDirty=!0,t.label=t.movedLabel,delete t.movedLabel}}export default Tick;