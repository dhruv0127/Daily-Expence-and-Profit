"use strict";import PU from"../PathUtilities.js";const getLinkPath=PU["getLinkPath"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:seriesProto},seriesTypes:{treemap:TreemapSeries,column:ColumnSeries}}=SeriesRegistry;import SVGRenderer from"../../Core/Renderer/SVG/SVGRenderer.js";const{symbols}=SVGRenderer["prototype"];import TreegraphNode from"./TreegraphNode.js";import TreegraphPoint from"./TreegraphPoint.js";import TU from"../TreeUtilities.js";const getLevelOptions=TU["getLevelOptions"];import U from"../../Core/Utilities.js";const{extend,isArray,merge,pick,relativeLength,splat}=U;import TreegraphLink from"./TreegraphLink.js";import TreegraphLayout from"./TreegraphLayout.js";import TreegraphSeriesDefaults from"./TreegraphSeriesDefaults.js";class TreegraphSeries extends TreemapSeries{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.points=void 0,this.layoutModifier=void 0,this.nodeMap=void 0,this.tree=void 0,this.nodeList=[],this.layoutAlgorythm=void 0,this.links=[],this.mapOptionsToLevel=void 0}init(){super.init.apply(this,arguments),this.layoutAlgorythm=new TreegraphLayout}getLayoutModifiers(){const e=this.chart,p=this,h=e.plotSizeX,d=e.plotSizeY;let g=1/0,k=-1/0,c=1/0,y=-1/0,m=0,v=0,T=0,u=0;this.points.forEach(e=>{const t=e.node,i=p.mapOptionsToLevel[e.node.level]||{},s=merge(this.options.marker,i.marker,e.options.marker),o=relativeLength(s.radius||0,Math.min(h,d)),r=s.symbol,a="circle"!==r&&s.height?relativeLength(s.height,d):2*o,l="circle"!==r&&s.width?relativeLength(s.width,h):2*o;t.nodeSizeX=l,t.nodeSizeY=a;let n;t.xPosition<=g&&(g=t.xPosition,n=s.lineWidth||0,v=Math.max(l+n,v)),t.xPosition>=k&&(k=t.xPosition,n=s.lineWidth||0,m=Math.max(l+n,m)),t.yPosition<=c&&(c=t.yPosition,n=s.lineWidth||0,u=Math.max(a+n,u)),t.yPosition>=y&&(y=t.yPosition,n=s.lineWidth||0,T=Math.max(a+n,T))});var t=y===c?1:(d-(u+T)/2)/(y-c),i=y===c?d/2:-t*c+u/2,s=k===g?1:(h-(m+m)/2)/(k-g);return{ax:s,bx:k===g?h/2:-s*g+v/2,ay:t,by:i}}getLinks(){const o=this,r=[];return this.data.forEach((e,t)=>{var i,s=o.mapOptionsToLevel[e.node.level||0]||{};e.node.parent?(s=merge(s,e.options),!e.linkToParent||e.linkToParent.destroyed?(i=(new o.LinkClass).init(o,s,void 0,e),e.linkToParent=i):e.linkToParent.update({collapsed:s.collapsed},!1),e.linkToParent.index=r.push(e.linkToParent)-1):e.linkToParent&&(o.links.splice(e.linkToParent.index),e.linkToParent.destroy(),delete e.linkToParent)}),r}buildTree(e,t,i,s,o){var r=this.points[t];return i=r&&r.level||i,super.buildTree.call(this,e,t,i,s,o)}markerAttribs(){return{}}setCollapsedStatus(e,t){const i=e.point;i&&(i.collapsed=pick(i.collapsed,(this.mapOptionsToLevel[e.level]||{}).collapsed),t=!1!==(i.visible=t)&&!i.collapsed),e.children.forEach(e=>{this.setCollapsedStatus(e,t)})}drawTracker(){ColumnSeries.prototype.drawTracker.apply(this,arguments),ColumnSeries.prototype.drawTracker.call(this,this.links)}translate(){var e=this,t=e.options;let i=TU.updateRootId(e),s;seriesProto.translate.call(e);var o=e.tree=e.getTree();s=e.nodeMap[i],""===i||s&&s.children.length||(e.setRootNode("",!1),i=e.rootNode,s=e.nodeMap[i]),e.mapOptionsToLevel=getLevelOptions({from:s.level+1,levels:t.levels,to:o.height,defaults:{levelIsConstant:e.options.levelIsConstant,colorByPoint:t.colorByPoint}}),this.setCollapsedStatus(o,!0),e.links=e.getLinks(),e.setTreeValues(o),this.layoutAlgorythm.calculatePositions(e),e.layoutModifier=this.getLayoutModifiers(),this.points.forEach(e=>{this.translateNode(e)}),this.points.forEach(e=>{e.linkToParent&&this.translateLink(e.linkToParent)}),t.colorByPoint||e.setColorRecursive(e.tree)}translateLink(i){var s=i.fromNode,o=i.toNode,r=this.options.link.lineWidth,a=Math.round(r)%2/2,l=pick(this.options.link.curveFactor,.5),n=pick(i.options.link&&i.options.link.type,this.options.link.type);if(s.shapeArgs&&o.shapeArgs){var p=s.shapeArgs.width||0,h=this.chart.inverted,d=Math.floor((s.shapeArgs.y||0)+(s.shapeArgs.height||0)/2)+a,g=Math.floor((o.shapeArgs.y||0)+(o.shapeArgs.height||0)/2)+a;let e=Math.floor((s.shapeArgs.x||0)+p)+a,t=Math.floor(o.shapeArgs.x||0)+a;h&&(e-=p,t+=o.shapeArgs.width||0);var s=o.node.xPosition-s.node.xPosition,k=(i.shapeType="path",Math.abs(t-e)+p),k=k/s-p,s=k*l*(h?-1:1),p=Math.floor((t+e)/2)+a;i.plotX=p,i.plotY=g,i.shapeArgs={d:getLinkPath[n]({x1:e,y1:d,x2:t,y2:g,width:k,offset:s,inverted:h,parentVisible:o.visible,radius:this.options.link.radius})},i.dlBox={x:(e+t)/2,y:(d+g)/2,height:r,width:0},i.tooltipPos=h?[(this.chart.plotSizeY||0)-i.dlBox.y,(this.chart.plotSizeX||0)-i.dlBox.x]:[i.dlBox.x,i.dlBox.y]}}drawNodeLabels(e){var t=this.mapOptionsToLevel;let i,s;for(const o of e)s=t[o.node.level],i={style:{}},s&&s.dataLabels&&(i=merge(i,s.dataLabels),this._hasPointLabels=!0),o.shapeArgs&&!splat(this.options.dataLabels)[0].style.width&&(i.style.width=o.shapeArgs.width,o.dataLabel&&o.dataLabel.css({width:o.shapeArgs.width+"px"})),o.dlOptions=merge(i,o.options.dataLabels);seriesProto.drawDataLabels.call(this,e)}alignDataLabel(e,t){var i=e.visible;e.visible=!0,super.alignDataLabel.apply(this,arguments),t.animate({opacity:!1===i?0:1}),e.visible=i}drawDataLabels(){this.options.dataLabels&&(this.options.dataLabels=splat(this.options.dataLabels),this.drawNodeLabels(this.points),seriesProto.drawDataLabels.call(this,this.links))}destroy(){if(this.links){for(const e of this.links)e.destroy();this.links.length=0}return seriesProto.destroy.apply(this,arguments)}pointAttribs(e,t){var i=this,s=i.mapOptionsToLevel[e.node.level||0]||{},o=e.options,r=s.states&&s.states[t]||{};e.options.marker=merge(i.options.marker,s.marker,e.options.marker);const a=pick(r.link&&r.link.color,o.link&&o.link.color,s.link&&s.link.color,i.options.link&&i.options.link.color),l=pick(r.link&&r.link.lineWidth,o.link&&o.link.lineWidth,s.link&&s.link.lineWidth,i.options.link&&i.options.link.lineWidth),n=seriesProto.pointAttribs.call(i,e,t);return e.isLink&&(n.stroke=a,n["stroke-width"]=l,delete n.fill),e.visible||(n.opacity=0),n}drawPoints(){TreemapSeries.prototype.drawPoints.apply(this,arguments),ColumnSeries.prototype.drawPoints.call(this,this.links)}translateNode(e){const t=this.chart,i=e.node,s=t.plotSizeY,o=t.plotSizeX,{ax:r,bx:a,ay:l,by:n}=this.layoutModifier,p=r*i.xPosition+a,h=l*i.yPosition+n,d=this.mapOptionsToLevel[i.level]||{},g=merge(this.options.marker,d.marker,e.options.marker),k=g.symbol,c=i.nodeSizeY,y=i.nodeSizeX,m=this.options.reversed,v=i.x=t.inverted?o-y/2-p:p-y/2,T=i.y=m?h-c/2:s-h-c/2,u=pick(e.options.borderRadius,d.borderRadius,this.options.borderRadius);if(e.shapeType="path",!e.visible&&e.linkToParent){var L=e.linkToParent.fromNode;if(L){const P=L.shapeArgs||{},{x:p=0,y:h=0,width:y=0,height:c=0}=P;e.shapeArgs||(e.shapeArgs={}),extend(e.shapeArgs,{d:symbols[k||"circle"](p,h,y,c,u?{r:u}:void 0),x:p,y:h}),e.plotX=L.plotX,e.plotY=L.plotY}}else e.plotX=v,e.plotY=T,e.shapeArgs={d:symbols[k||"circle"](v,T,y,c,u?{r:u}:void 0),x:v,y:T,width:y,height:c,cursor:e.node.isLeaf?"default":"pointer"};e.tooltipPos=t.inverted?[s-T-c/2,o-v-y/2]:[v+y/2,T]}}TreegraphSeries.defaultOptions=merge(TreemapSeries.defaultOptions,TreegraphSeriesDefaults),extend(TreegraphSeries.prototype,{pointClass:TreegraphPoint,NodeClass:TreegraphNode,LinkClass:TreegraphLink}),SeriesRegistry.registerSeriesType("treegraph",TreegraphSeries);export default TreegraphSeries;