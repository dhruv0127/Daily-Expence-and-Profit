"use strict";import ColumnSeries from"./Column/ColumnSeries.js";const columnProto=ColumnSeries["prototype"];import Series from"../Core/Series/Series.js";const seriesProto=Series["prototype"];import U from"../Core/Utilities.js";const{defined,stableSort}=U;var OnSeriesComposition;!function(t){const e=[];function s(t){return seriesProto.getPlotBox.call(this.options.onSeries&&this.chart.get(this.options.onSeries)||this,t)}function i(){columnProto.translate.apply(this);const s=this,t=s.options,o=s.chart,i=s.points,e=t.onSeries,n=e&&o.get(e),r=n&&n.options.step,p=n&&n.points,l=o.inverted,a=s.xAxis,x=s.yAxis;let c=i.length-1,u,f,m=t.onKey||"y",S=p&&p.length,y=0,d,h,C,g,v;if(n&&n.visible&&S)for(y=(n.pointXOffset||0)+(n.barW||0)/2,g=n.currentDataGrouping,h=p[S-1].x+(g?g.totalRange:0),stableSort(i,(t,o)=>t.x-o.x),m="plot"+m[0].toUpperCase()+m.substr(1);S--&&i[c]&&(d=p[S],(u=i[c]).y=d.y,!(d.x<=u.x&&void 0!==d[m]&&(u.x<=h&&(u.plotY=d[m],d.x<u.x&&!r&&(C=p[S+1])&&void 0!==C[m]&&(v=(u.x-d.x)/(C.x-d.x),u.plotY+=v*(C[m]-d[m]),u.y+=v*(C.y-d.y))),c--,S++,c<0))););i.forEach((t,o)=>{let e;t.plotX+=y,void 0!==t.plotY&&!l||(0<=t.plotX&&t.plotX<=a.len?l?(t.plotY=a.translate(t.x,0,1,0,1),t.plotX=defined(t.y)?x.translate(t.y,0,0,0,1):0):t.plotY=(a.opposite?0:s.yAxis.len)+a.offset:t.shapeArgs={}),(f=i[o-1])&&f.plotX===t.plotX&&(void 0===f.stackIndex&&(f.stackIndex=0),e=f.stackIndex+1),t.stackIndex=e}),this.onSeries=n}t.compose=function(t){if(U.pushUnique(e,t)){const o=t.prototype;o.getPlotBox=s,o.translate=i}return t},t.getPlotBox=s,t.translate=i}(OnSeriesComposition=OnSeriesComposition||{});export default OnSeriesComposition;