"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import DependencyWheelPoint from"./DependencyWheelPoint.js";import DependencyWheelSeriesDefaults from"./DependencyWheelSeriesDefaults.js";import H from"../../Core/Globals.js";const deg2rad=H["deg2rad"];import SankeyColumnComposition from"../Sankey/SankeyColumnComposition.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{pie:PieSeries,sankey:SankeySeries}=SeriesRegistry["seriesTypes"];import U from"../../Core/Utilities.js";const{extend,merge}=U;class DependencyWheelSeries extends SankeySeries{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.nodeColumns=void 0,this.nodes=void 0,this.points=void 0}animate(e){if(!e){const t=animObject(this.options.animation).duration,n=t/2/this.nodes.length;this.nodes.forEach(function(e,t){const i=e.graphic;i&&(i.attr({opacity:0}),setTimeout(function(){e.graphic&&e.graphic.animate({opacity:1},{duration:n})},n*t))},this),this.points.forEach(function(e){const t=e.graphic;!e.isNode&&t&&t.attr({opacity:0}).animate({opacity:1},this.options.animation)},this)}}createNode(e){const r=SankeySeries.prototype.createNode.call(this,e);return r.getSum=function(){return r.linksFrom.concat(r.linksTo).reduce(function(e,t){return e+t.weight},0)},r.offset=function(e){let t=0,i,n=r.linksFrom.concat(r.linksTo),o;function s(e){return e.fromNode===r?e.toNode:e.fromNode}for(n.sort(function(e,t){return s(e).index-s(t).index}),i=0;i<n.length;i++)if(s(n[i]).index>r.index){n=n.slice(0,i).reverse().concat(n.slice(i).reverse()),o=!0;break}for(o||n.reverse(),i=0;i<n.length;i++){if(n[i]===e)return t;t+=n[i].weight}},r}createNodeColumns(){const t=[SankeyColumnComposition.compose([],this)];return this.nodes.forEach(function(e){e.column=0,t[0].push(e)}),t}getNodePadding(){return this.options.nodePadding/Math.PI}translate(){const h=this.options,l=2*Math.PI/(this.chart.plotHeight+this.getNodePadding()),s=this.getCenter(),y=(h.startAngle-90)*deg2rad,e=h.borderRadius,r="object"==typeof e?e.radius:e;SankeySeries.prototype.translate.call(this),this.nodeColumns[0].forEach(function(e){if(e.sum){const t=e.shapeArgs,c=s[0],p=s[1],i=s[2]/2,d=i-h.nodeWidth,n=y+l*(t.y||0),o=y+l*((t.y||0)+(t.height||0));e.angle=n+(o-n)/2,e.shapeType="arc",e.shapeArgs={x:c,y:p,r:i,innerR:d,start:n,end:o,borderRadius:r},e.dlBox={x:c+Math.cos((n+o)/2)*(i+d)/2,y:p+Math.sin((n+o)/2)*(i+d)/2,width:1,height:1},e.linksFrom.forEach(function(a){if(a.linkBase){let r;var e=a.linkBase.map(function(e,t){let i=l*e,n=Math.cos(y+i)*(1+d),o=Math.sin(y+i)*(1+d),s=h.curveFactor||0;return(r=Math.abs(a.linkBase[3-t]*l-i))>Math.PI&&(r=2*Math.PI-r),(r*=d)<d&&(s*=r/d),{x:c+n,y:p+o,cpX:c+(1-s)*n,cpY:p+(1-s)*o}});a.shapeArgs={d:[["M",e[0].x,e[0].y],["A",d,d,0,0,1,e[1].x,e[1].y],["C",e[1].cpX,e[1].cpY,e[2].cpX,e[2].cpY,e[2].x,e[2].y],["A",d,d,0,0,1,e[3].x,e[3].y],["C",e[3].cpX,e[3].cpY,e[0].cpX,e[0].cpY,e[0].x,e[0].y]]}}})}})}}DependencyWheelSeries.defaultOptions=merge(SankeySeries.defaultOptions,DependencyWheelSeriesDefaults),extend(DependencyWheelSeries.prototype,{orderNodes:!1,getCenter:PieSeries.prototype.getCenter}),DependencyWheelSeries.prototype.pointClass=DependencyWheelPoint,SeriesRegistry.registerSeriesType("dependencywheel",DependencyWheelSeries);export default DependencyWheelSeries;