"use strict";import Color from"../../Core/Color/Color.js";import H from"../../Core/Globals.js";import NodesComposition from"../NodesComposition.js";import SankeyPoint from"./SankeyPoint.js";import SankeySeriesDefaults from"./SankeySeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";import SankeyColumnComposition from"./SankeyColumnComposition.js";const{series:Series,seriesTypes:{column:ColumnSeries}}=SeriesRegistry;import TU from"../TreeUtilities.js";const getLevelOptions=TU["getLevelOptions"];import U from"../../Core/Utilities.js";const{extend,isObject,merge,pick,relativeLength,stableSort}=U;class SankeySeries extends ColumnSeries{constructor(){super(...arguments),this.colDistance=void 0,this.data=void 0,this.group=void 0,this.nodeLookup=void 0,this.nodePadding=void 0,this.nodes=void 0,this.nodeWidth=void 0,this.options=void 0,this.points=void 0,this.translationFactor=void 0}static getDLOptions(o){var t=isObject(o.optionsPoint)?o.optionsPoint.dataLabels:{},o=isObject(o.level)?o.level.dataLabels:{};return merge({style:{}},o,t)}createNodeColumns(){const t=[];this.nodes.forEach(function(o){o.setNodeColumn(),t[o.column]||(t[o.column]=SankeyColumnComposition.compose([],this)),t[o.column].push(o)},this);for(let o=0;o<t.length;o++)void 0===t[o]&&(t[o]=SankeyColumnComposition.compose([],this));return t}order(o,t){const e=this;void 0===o.level&&(o.level=t,o.linksFrom.forEach(function(o){o.toNode&&e.order(o.toNode,t+1)}))}generatePoints(){NodesComposition.generatePoints.apply(this,arguments);const t=this;this.orderNodes&&(this.nodes.filter(function(o){return 0===o.linksTo.length}).forEach(function(o){t.order(o,0)}),stableSort(this.nodes,function(o,t){return o.level-t.level}))}getNodePadding(){let o=this.options.nodePadding||0;var t;return o=this.nodeColumns&&(t=this.nodeColumns.reduce((o,t)=>Math.max(o,t.length),0))*o>this.chart.plotSizeY?this.chart.plotSizeY/t:o}hasData(){return!!this.processedXData.length}pointAttribs(o,t){if(!o)return{};const e=this,i=(o.isNode?o:o.fromNode).level,s=e.mapOptionsToLevel[i||0]||{},n=o.options,r=s.states&&s.states[t||""]||{},a=["colorByPoint","borderColor","borderWidth","linkOpacity","opacity"].reduce(function(o,t){return o[t]=pick(r[t],n[t],s[t],e.options[t]),o},{}),l=pick(r.color,n.color,(a.colorByPoint?o:s).color);return o.isNode?{fill:l,stroke:a.borderColor,"stroke-width":a.borderWidth,opacity:a.opacity}:{fill:Color.parse(l).setOpacity(a.linkOpacity).get()}}drawTracker(){ColumnSeries.prototype.drawTracker.call(this,this.points),ColumnSeries.prototype.drawTracker.call(this,this.nodes)}drawPoints(){ColumnSeries.prototype.drawPoints.call(this,this.points),ColumnSeries.prototype.drawPoints.call(this,this.nodes)}drawDataLabels(){ColumnSeries.prototype.drawDataLabels.call(this,this.points),ColumnSeries.prototype.drawDataLabels.call(this,this.nodes)}translate(){this.processedXData||this.processData(),this.generatePoints(),this.nodeColumns=this.createNodeColumns(),this.nodeWidth=relativeLength(this.options.nodeWidth,this.chart.plotSizeX);const e=this,o=this.chart,t=this.options,i=this.nodeWidth,s=this.nodeColumns;this.nodePadding=this.getNodePadding(),this.translationFactor=s.reduce((o,t)=>Math.min(o,t.sankeyColumn.getTranslationFactor(e)),1/0),this.colDistance=(o.plotSizeX-i-t.borderWidth)/Math.max(1,s.length-1),e.mapOptionsToLevel=getLevelOptions({from:1,levels:t.levels,to:s.length-1,defaults:{borderColor:t.borderColor,borderRadius:t.borderRadius,borderWidth:t.borderWidth,color:e.color,colorByPoint:t.colorByPoint,levelIsConstant:!0,linkColor:t.linkColor,linkLineWidth:t.linkLineWidth,linkOpacity:t.linkOpacity,states:t.states}}),s.forEach(function(t){t.forEach(function(o){e.translateNode(o,t)})},this),this.nodes.forEach(function(o){o.linksFrom.forEach(function(o){(o.weight||o.isNull)&&o.to&&(e.translateLink(o),o.allowShadow=!1)})})}translateLink(e){var o,t,i,s,n,r,a,l,d,h,p,c,m,u,S,y,C,f,g=(o,t)=>{t=o.offset(e,t)*b;return Math.min(o.nodeY+t,o.nodeY+(o.shapeArgs&&o.shapeArgs.height||0)-P)};let k=e.fromNode,v=e.toNode,L=this.chart,b=this.translationFactor,P=Math.max(e.weight*b,this.options.minLinkWidth),N=this.options,w=(L.inverted?-this.colDistance:this.colDistance)*N.curveFactor,O=g(k,"linksFrom"),T=g(v,"linksTo"),x=k.nodeX,D=this.nodeWidth,W=v.nodeX,M=e.outgoing,j=W>x+D;L.inverted&&(O=L.plotSizeY-O,T=(L.plotSizeY||0)-T,D=-D,P=-P,j=W<x),e.shapeType="path",e.linkBase=[O,O+P,T,T+P],j&&"number"==typeof T?e.shapeArgs={d:[["M",x+D,O],["C",x+D+w,O,W-w,T,W,T],["L",W+(M?D:0),T+P/2],["L",W,T+P],["C",W-w,T+P,x+D+w,O+P,x+D,O+P],["Z"]]}:"number"==typeof T&&(g=L.plotHeight-O-P,o=W-20-P,t=W-20,n=(s=(i=x+D)+20)+P,h=(d=(g=(l=(a=(r=O)+P)+20)+g)+20)+P,m=(c=(p=T)+P)+20,u=a-.7*P,S=d+.7*P,y=c-.7*P,C=W-.7*P,f=i+.7*P,e.shapeArgs={d:[["M",i,r],["C",f,r,n,u,n,l],["L",n,g],["C",n,S,f,h,i,h],["L",W,h],["C",C,h,o,S,o,g],["L",o,m],["C",o,y,C,p,W,p],["L",W,c],["C",t,c,t,c,t,m],["L",t,g],["C",t,d,t,d,W,d],["L",i,d],["C",s,d,s,d,s,g],["L",s,l],["C",s,a,s,a,i,a],["Z"]]}),e.dlBox={x:x+(W-x+D)/2,y:O+(T-O)/2,height:P,width:0},e.tooltipPos=L.inverted?[L.plotSizeY-e.dlBox.y-P/2,L.plotSizeX-e.dlBox.x]:[e.dlBox.x,e.dlBox.y+P/2],e.y=e.plotY=1,e.x=e.plotX=1,e.color||(e.color=k.color)}translateNode(s,n){var o=this.translationFactor,r=this.chart,a=this.options,{borderRadius:l,borderWidth:d=0}=a,t=s.getSum(),h=Math.max(Math.round(t*o),this.options.minLinkWidth),p=Math.round(this.nodeWidth),e=Math.round(d)%2/2,c=n.sankeyColumn.offset(s,o),n=Math.floor(pick(c.absoluteTop,n.sankeyColumn.top(o)+c.relativeTop))+e,o=Math.floor(this.colDistance*s.column+d/2)+relativeLength(s.options.offsetHorizontal||0,p)+e,c=r.inverted?r.plotSizeX-o:o;if(s.sum=t){s.shapeType="roundedRect";let o=s.nodeX=c,t=s.nodeY=n,e=s.options.width||a.width||p,i=s.options.height||a.height||h;d=relativeLength("object"==typeof l?l.radius:l||0,e);r.inverted&&(o=c-p,t=r.plotSizeY-n-h,e=s.options.height||a.height||p,i=s.options.width||a.width||h),s.dlOptions=SankeySeries.getDLOptions({level:this.mapOptionsToLevel[s.level],optionsPoint:s.options}),s.plotX=1,s.plotY=1,s.tooltipPos=r.inverted?[r.plotSizeY-t-i/2,r.plotSizeX-o-e/2]:[o+e/2,t+i/2],s.shapeArgs={x:o,y:t,width:e,height:i,r:d,display:s.hasShape()?"":"none"}}else s.dlOptions={enabled:!1}}}SankeySeries.defaultOptions=merge(ColumnSeries.defaultOptions,SankeySeriesDefaults),NodesComposition.compose(SankeyPoint,SankeySeries),extend(SankeySeries.prototype,{animate:Series.prototype.animate,createNode:NodesComposition.createNode,forceDL:!0,invertible:!0,isCartesian:!1,orderNodes:!0,noSharedTooltip:!0,pointArrayMap:["from","to","weight"],pointClass:SankeyPoint,searchPoint:H.noop}),SeriesRegistry.registerSeriesType("sankey",SankeySeries);export default SankeySeries;