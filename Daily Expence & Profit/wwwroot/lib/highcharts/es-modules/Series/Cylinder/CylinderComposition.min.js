"use strict";import Color from"../../Core/Color/Color.js";const color=Color["parse"];import H from"../../Core/Globals.js";const{charts,deg2rad}=H;import Math3D from"../../Core/Math3D.js";const perspective=Math3D["perspective"];import RendererRegistry from"../../Core/Renderer/RendererRegistry.js";import U from"../../Core/Utilities.js";const{merge,pick}=U,rendererProto=RendererRegistry.getRendererType().prototype,cuboidPath=rendererProto.cuboidPath,isSimplified=e=>!e.some(e=>"C"===e[0]),cylinderMethods=merge(rendererProto.elements3d.cuboid,{parts:["top","bottom","front","back"],pathType:"cylinder",fillSetter:function(e){return this.singleSetterForParts("fill",null,{front:e,back:e,top:color(e).brighten(.1).get(),bottom:color(e).brighten(-.1).get()}),this.color=this.fill=e,this}});rendererProto.elements3d.cylinder=cylinderMethods,rendererProto.cylinder=function(e){return this.element3d("cylinder",e)},rendererProto.cylinderPath=function(e){var r=this,t=charts[r.chartIndex],o=cuboidPath.call(r,e),n=!o.isTop,i=!o.isFront,s=r.getCylinderEnd(t,e),t=r.getCylinderEnd(t,e,!0);return{front:r.getCylinderFront(s,t),back:r.getCylinderBack(s,t),top:s,bottom:t,zIndexes:{top:n?3:0,bottom:n?0:3,front:i?2:1,back:i?1:2,group:o.zIndexes.group}}},rendererProto.getCylinderFront=function(e,r){const t=e.slice(0,3);var o;return isSimplified(r)?"M"===(e=r[0])[0]&&(t.push(r[2]),t.push(r[1]),t.push(["L",e[1],e[2]])):(e=r[0],o=r[1],r=r[2],"M"===e[0]&&"C"===o[0]&&"C"===r[0]&&(t.push(["L",r[5],r[6]]),t.push(["C",r[3],r[4],r[1],r[2],o[5],o[6]]),t.push(["C",o[3],o[4],o[1],o[2],e[1],e[2]]))),t.push(["Z"]),t},rendererProto.getCylinderBack=function(e,r){const t=[];var o,n;return isSimplified(e)?(o=e[0],n=e[2],"M"===o[0]&&"L"===n[0]&&(t.push(["M",n[1],n[2]]),t.push(e[3]),t.push(["L",o[1],o[2]]))):("C"===e[2][0]&&t.push(["M",e[2][5],e[2][6]]),t.push(e[3],e[4])),isSimplified(r)?"M"===(n=r[0])[0]&&(t.push(["L",n[1],n[2]]),t.push(r[3]),t.push(r[2])):(o=r[2],e=r[3],n=r[4],"C"===o[0]&&"C"===e[0]&&"C"===n[0]&&(t.push(["L",n[5],n[6]]),t.push(["C",n[3],n[4],n[1],n[2],e[5],e[6]]),t.push(["C",e[3],e[4],e[1],e[2],o[5],o[6]]))),t.push(["Z"]),t},rendererProto.getCylinderEnd=function(e,r,t){var{width:o=0,height:n=0,alphaCorrection:i=0}=r;let s=pick(r.depth,o,0),h=Math.min(o,s)/2,d=deg2rad*(e.options.chart.options3d.beta-90+i),p=(r.y||0)+(t?n:0),c=.5519*h,l=o/2+(r.x||0),u=s/2+(r.z||0),a=[{x:0,y:p,z:h},{x:c,y:p,z:h},{x:h,y:p,z:c},{x:h,y:p,z:0},{x:h,y:p,z:-c},{x:c,y:p,z:-h},{x:0,y:p,z:-h},{x:-c,y:p,z:-h},{x:-h,y:p,z:-c},{x:-h,y:p,z:0},{x:-h,y:p,z:c},{x:-c,y:p,z:h},{x:0,y:p,z:h}],y=Math.cos(d),C=Math.sin(d),f,g,m,x;return a.forEach(function(e,r){m=e.x,x=e.z,a[r].x=m*y-x*C+l,a[r].z=x*y+m*C+u}),f=perspective(a,e,!0),g=Math.abs(f[3].y-f[9].y)<2.5&&Math.abs(f[0].y-f[6].y)<2.5?this.toLinePath([f[0],f[3],f[6],f[9]],!0):this.getCurvedPath(f)},rendererProto.getCurvedPath=function(e){let r=[["M",e[0].x,e[0].y]],t=e.length-2,o;for(o=1;o<t;o+=3)r.push(["C",e[o].x,e[o].y,e[o+1].x,e[o+1].y,e[o+2].x,e[o+2].y]);return r};