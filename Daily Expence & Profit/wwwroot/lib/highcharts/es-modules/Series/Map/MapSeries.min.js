"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import ColorMapComposition from"../ColorMapComposition.js";import CU from"../CenteredUtilities.js";import H from"../../Core/Globals.js";const noop=H["noop"];import MapChart from"../../Core/Chart/MapChart.js";const splitPath=MapChart["splitPath"];import MapPoint from"./MapPoint.js";import MapView from"../../Maps/MapView.js";import Series from"../../Core/Series/Series.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,scatter:ScatterSeries}=SeriesRegistry["seriesTypes"];import SVGRenderer from"../../Core/Renderer/SVG/SVGRenderer.js";import U from"../../Core/Utilities.js";const{extend,find,fireEvent,getNestedProperty,isArray,defined,isNumber,isObject,merge,objectEach,pick,splat}=U;class MapSeries extends ScatterSeries{constructor(){super(...arguments),this.chart=void 0,this.data=void 0,this.group=void 0,this.joinBy=void 0,this.options=void 0,this.points=void 0,this.processedData=[]}animate(t){const{chart:e,group:s}=this,o=animObject(this.options.animation);t?s.attr({translateX:e.plotLeft+e.plotWidth/2,translateY:e.plotTop+e.plotHeight/2,scaleX:.001,scaleY:.001}):s.animate({translateX:e.plotLeft,translateY:e.plotTop,scaleX:1,scaleY:1},o)}clearBounds(){this.points.forEach(t=>{delete t.bounds,delete t.insetIndex,delete t.projectedPath}),delete this.bounds}doFullTranslate(){return Boolean(this.isDirtyData||this.chart.isResizing||!this.hasRendered)}drawMapDataLabels(){Series.prototype.drawDataLabels.call(this),this.dataLabelsGroup&&this.dataLabelsGroup.clip(this.chart.clipRect)}drawPoints(){const c=this,{chart:m,group:s,transformGroups:o=[]}=this,{mapView:u,renderer:f}=m;u&&((this.transformGroups=o)[0]||(o[0]=f.g().add(s)),u.insets.forEach((t,e)=>{o[e+1]||o.push(f.g().add(s))}),this.doFullTranslate()&&(this.points.forEach(t=>{const{graphic:e,shapeArgs:s}=t;t.group=o["number"==typeof t.insetIndex?t.insetIndex+1:0],e&&e.parentGroup!==t.group&&e.add(t.group),s&&m.hasRendered&&!m.styledMode&&(s.fill=this.pointAttribs(t,t.state).fill)}),ColumnSeries.prototype.drawPoints.apply(this),this.points.forEach(e=>{const a=e.graphic;if(a){const n=a.animate;let t="";e.name&&(t+="highcharts-name-"+e.name.replace(/ /g,"-").toLowerCase()),e.properties&&e.properties["hc-key"]&&(t+=" highcharts-key-"+e.properties["hc-key"].toString().toLowerCase()),t&&a.addClass(t),m.styledMode&&a.css(this.pointAttribs(e,e.selected?"select":void 0)),a.animate=function(t,e,s){var o,i=isNumber(t["stroke-width"])&&!isNumber(a["stroke-width"]),r=isNumber(a["stroke-width"])&&!isNumber(t["stroke-width"]),i=((i||r)&&(o=pick(c.getStrokeWidth(c.options),1)/(m.mapView&&m.mapView.getScale()||1),i&&(a["stroke-width"]=o),r&&(t["stroke-width"]=o)),n.call(a,t,e,r?function(){a.element.removeAttribute("stroke-width"),delete a["stroke-width"],s&&s.apply(this,arguments)}:s));return i}}})),o.forEach((o,t)=>{const e=0===t?u:u.insets[t-1],i=e.getSVGTransform(),r=pick(this.getStrokeWidth(this.options),1),a=i.scaleX,n=0<i.scaleY?1:-1,p=o=>{(c.points||[]).forEach(t=>{const e=t.graphic;let s;e&&e["stroke-width"]&&(s=this.getStrokeWidth(t.options))&&e.attr({"stroke-width":s/o})})};if(f.globalAnimation&&m.hasRendered&&u.allowTransformAnimation){const l=Number(o.attr("translateX")),h=Number(o.attr("translateY")),d=Number(o.attr("scaleX"));let t={};if("boolean"!=typeof(t=m.options.chart?merge({},m.options.chart.animation):t)){const s=t.step;t.step=function(t){s&&s.apply(this,arguments),((t,e)=>{var s=d+(a-d)*e.pos;o.attr({translateX:l+(i.translateX-l)*e.pos,translateY:h+(i.translateY-h)*e.pos,scaleX:s,scaleY:s*n,"stroke-width":r/s}),p(s)}).apply(this,arguments)}}o.attr({animator:0}).animate({animator:1},t,function(){"boolean"!=typeof f.globalAnimation&&f.globalAnimation.complete&&f.globalAnimation.complete({applyDrilldown:!0})})}else o.attr(merge(i,{"stroke-width":r/a})),p(a)}),this.isDrilling||this.drawMapDataLabels())}getProjectedBounds(){if(!this.bounds&&this.chart.mapView){const{insets:r,projection:a}=this.chart.mapView,t=[];(this.points||[]).forEach(function(e){if(e.path||e.geometry){if("string"==typeof e.path?e.path=splitPath(e.path):isArray(e.path)&&"M"===e.path[0]&&(e.path=SVGRenderer.prototype.pathToSegments(e.path)),!e.bounds){let t=e.getProjectedBounds(a);if(t){e.labelrank=pick(e.labelrank,(t.x2-t.x1)*(t.y2-t.y1));const{midX:s,midY:o}=t;if(r&&isNumber(s)&&isNumber(o)){const i=find(r,t=>t.isInside({x:s,y:o}));i&&(delete e.projectedPath,(t=e.getProjectedBounds(i.projection))&&i.allBounds.push(t),e.insetIndex=r.indexOf(i))}e.bounds=t}}e.bounds&&void 0===e.insetIndex&&t.push(e.bounds)}}),this.bounds=MapView.compositeBounds(t)}return this.bounds}getStrokeWidth(t){var e=this.pointAttrToOptions;return t[e&&e["stroke-width"]||"borderWidth"]}hasData(){return!!this.processedXData.length}pointAttribs(t,e){var s;const{mapView:o,styledMode:i}=t.series.chart,r=i?this.colorAttribs(t):ColumnSeries.prototype.pointAttribs.call(this,t,e);let a=this.getStrokeWidth(t.options);e&&(e=merge(this.options.states[e],t.options.states&&t.options.states[e]||{}),s=this.getStrokeWidth(e),defined(s)&&(a=s),r.stroke=null!=(s=e.borderColor)?s:t.color),a&&o&&(a/=o.getScale());e=this.getStrokeWidth(this.options);return r.dashstyle&&o&&isNumber(e)&&(a=e/o.getScale()),t.visible||(r.fill=this.options.nullColor),defined(a)?r["stroke-width"]=a:delete r["stroke-width"],r["stroke-linecap"]=r["stroke-linejoin"]=this.options.linecap,r}updateData(){return!this.processedData&&super.updateData.apply(this,arguments)}setData(t,e=!0,s,o){delete this.bounds,super.setData.call(this,t,!1,void 0,o),this.processData(),this.generatePoints(),e&&this.chart.redraw(s)}processData(){const t=this.options,i=t.data,e=this.chart.options.chart,r=this.joinBy,a=t.keys||this.pointArrayMap,s=[],o={};let n=this.chart.mapView,p=n&&(isObject(t.mapData,!0)?n.getGeoMap(t.mapData):n.geoMap),l=this.chart.mapTransforms,h,d,c;this.chart.mapTransforms=l=e.mapTransforms||p&&p["hc-transform"]||l,l&&objectEach(l,function(t){t.rotation&&(t.cosAngle=Math.cos(t.rotation),t.sinAngle=Math.sin(t.rotation))});let m;isArray(t.mapData)?m=t.mapData:p&&"FeatureCollection"===p.type&&(this.mapTitle=p.title,m=H.geojson(p,this.type,this)),this.processedData=[];const u=this.processedData;if(i&&i.forEach(function(e,s){let o=0;if(isNumber(e))u[s]={value:e};else if(isArray(e)){u[s]={},!t.keys&&e.length>a.length&&"string"==typeof e[0]&&(u[s]["hc-key"]=e[0],++o);for(let t=0;t<a.length;++t,++o)a[t]&&void 0!==e[o]&&(0<a[t].indexOf(".")?MapPoint.prototype.setNestedProperty(u[s],e[o],a[t]):u[s][a[t]]=e[o])}else u[s]=i[s];r&&"_i"===r[0]&&(u[s]._i=s)}),m){for(this.mapData=m,this.mapMap={},c=0;c<m.length;c++)d=(h=m[c]).properties,h._i=c,r[0]&&d&&d[r[0]]&&(h[r[0]]=d[r[0]]),o[h[r[0]]]=h;if(this.mapMap=o,r[1]){const f=r[1];u.forEach(function(t){t=getNestedProperty(f,t);o[t]&&s.push(o[t])})}if(t.allAreas){if(r[1]){const g=r[1];u.forEach(function(t){s.push(getNestedProperty(g,t))})}const b="|"+s.map(function(t){return t&&t[r[0]]}).join("|")+"|";m.forEach(function(t){r[0]&&-1!==b.indexOf("|"+t[r[0]]+"|")||u.push(merge(t,{value:null}))})}}this.processedXData=new Array(u.length)}setOptions(t){let e=Series.prototype.setOptions.call(this,t),s=e.joinBy,o=null===s;return o&&(s="_i"),(s=this.joinBy=splat(s))[1]||(s[1]=s[0]),e}translate(){const s=this.doFullTranslate(),o=this.chart.mapView,i=o&&o.projection;if(!this.chart.hasRendered||!this.isDirtyData&&this.hasRendered||(this.processData(),this.generatePoints(),delete this.bounds,!o||o.userOptions.center||isNumber(o.userOptions.zoom)||o.zoom!==o.minZoom?this.getProjectedBounds():o.fitToBounds(void 0,void 0,!1)),o){const r=o.getSVGTransform();this.points.forEach(function(t){var e=isNumber(t.insetIndex)&&o.insets[t.insetIndex].getSVGTransform()||r;e&&t.bounds&&isNumber(t.bounds.midX)&&isNumber(t.bounds.midY)&&(t.plotX=t.bounds.midX*e.scaleX+e.translateX,t.plotY=t.bounds.midY*e.scaleY+e.translateY),s&&(t.shapeType="path",t.shapeArgs={d:MapPoint.getProjectedPath(t,i)}),t.projectedPath&&!t.projectedPath.length?t.setVisible(!1):t.setVisible(!0)})}fireEvent(this,"afterTranslate")}}MapSeries.defaultOptions=merge(ScatterSeries.defaultOptions,{affectsMapView:!0,animation:!1,dataLabels:{crop:!1,formatter:function(){const t=this.series.chart["numberFormatter"];var e=this.point["value"];return isNumber(e)?t(e,-1):""},inside:!0,overflow:!1,padding:0,verticalAlign:"middle"},linecap:"round",marker:null,nullColor:"#f7f7f7",stickyTracking:!1,tooltip:{followPointer:!0,pointFormat:"{point.name}: {point.value}<br/>"},turboThreshold:0,allAreas:!0,borderColor:"#e6e6e6",borderWidth:1,joinBy:"hc-key",states:{hover:{halo:void 0,borderColor:"#666666",borderWidth:2},normal:{animation:!0},select:{color:"#cccccc"}},legendSymbol:"rectangle"}),extend(MapSeries.prototype,{type:"map",axisTypes:ColorMapComposition.seriesMembers.axisTypes,colorAttribs:ColorMapComposition.seriesMembers.colorAttribs,colorKey:ColorMapComposition.seriesMembers.colorKey,directTouch:!0,drawDataLabels:noop,drawGraph:noop,forceDL:!0,getCenter:CU.getCenter,getExtremesFromAll:!0,getSymbol:noop,isCartesian:!1,parallelArrays:ColorMapComposition.seriesMembers.parallelArrays,pointArrayMap:ColorMapComposition.seriesMembers.pointArrayMap,pointClass:MapPoint,preserveAspectRatio:!0,searchPoint:noop,trackerGroups:ColorMapComposition.seriesMembers.trackerGroups,useMapGeometry:!0}),ColorMapComposition.compose(MapSeries),SeriesRegistry.registerSeriesType("map",MapSeries);export default MapSeries;