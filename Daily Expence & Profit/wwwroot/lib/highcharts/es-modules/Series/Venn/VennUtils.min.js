"use strict";import CU from"../../Core/Geometry/CircleUtilities.js";const{getAreaOfCircle,getCircleCircleIntersection,getOverlapBetweenCircles:getOverlapBetweenCirclesByDistance,isPointInsideAllCircles,isPointInsideCircle,isPointOutsideAllCircles}=CU;import GU from"../../Core/Geometry/GeometryUtilities.js";const getDistanceBetweenPoints=GU["getDistanceBetweenPoints"];import U from"../../Core/Utilities.js";const{extend,isArray,isNumber,isObject,isString}=U;function addOverlapToSets(e){const s={};return e.filter(e=>2===e.sets.length).forEach(n=>{n.sets.forEach((e,t,r)=>{isObject(s[e])||(s[e]={totalOverlap:0,overlapping:{}}),s[e]={totalOverlap:(s[e].totalOverlap||0)+n.value,overlapping:Object.assign(Object.assign({},s[e].overlapping||{}),{[r[1-t]]:n.value})}})}),e.filter(isSet).forEach(e=>{var t=s[e.sets[0]];extend(e,t)}),e}function bisect(e,t,r,n,s){let i=e(t),o=e(r),l=s||100,c=n||1e-10,a=r-t,u=1,f,d;if(r<=t)throw new Error("a must be smaller than b.");if(0<i*o)throw new Error("f(a) and f(b) must have opposite signs.");if(0===i)f=t;else if(0===o)f=r;else for(;u++<=l&&0!==d&&a>c;)a=(r-t)/2,f=t+a,0<i*(d=e(f))?t=f:r=f;return f}function getCentroid(e){function t(e,t){return e.sum+=t[e.i],e}const r=e.slice(0,-1),n=r.length,s=[];for(let e=0;e<n;e++)s[e]=r.reduce(t,{sum:0,i:e}).sum/n;return s}function getDistanceBetweenCirclesByOverlap(t,r,n){let e=t+r,s;return s=n<=0?e:getAreaOfCircle(t<r?t:r)<=n?0:bisect(e=>{e=getOverlapBetweenCirclesByDistance(t,r,e);return n-e},0,e)}function getLabelWidth(s,i,e){const t=i.reduce((e,t)=>Math.min(t.r,e),1/0),o=e.filter(function(e){return!isPointInsideCircle(s,e)});function r(r,n){return bisect(function(e){var t={x:s.x+n*e,y:s.y},t=isPointInsideAllCircles(t,i)&&isPointOutsideAllCircles(t,o);return-(r-e)+(t?0:Number.MAX_VALUE)},0,r)}return 2*Math.min(r(t,-1),r(t,1))}function getMarginFromCircles(r,e,t){e=e.reduce(function(e,t){t=t.r-getDistanceBetweenPoints(r,t);return t<=e?t:e},Number.MAX_VALUE);return t.reduce(function(e,t){t=getDistanceBetweenPoints(r,t)-t.r;return t<=e?t:e},e)}function getOverlapBetweenCircles(e){let t=0;var r;return 2===e.length&&(r=e[0],e=e[1],t=getOverlapBetweenCirclesByDistance(r.r,e.r,getDistanceBetweenPoints(r,e))),t}function isSet(e){return isArray(e.sets)&&1===e.sets.length}function isValidRelation(e){const r={};return isObject(e)&&isNumber(e.value)&&-1<e.value&&isArray(e.sets)&&0<e.sets.length&&!e.sets.some(function(e){let t=!1;return!r[e]&&isString(e)?r[e]=!0:t=!0,t})}function isValidSet(e){return isValidRelation(e)&&isSet(e)&&0<e.value}function layoutGreedyVenn(e){function r(e,t){const r=e.circle;r&&(r.x=t.x,r.y=t.y),a.push(e)}const a=[],u={},t=(e.filter(function(e){return 1===e.sets.length}).forEach(function(e){u[e.sets[0]]=e.circle={x:Number.MAX_VALUE,y:Number.MAX_VALUE,r:Math.sqrt(e.value/Math.PI)}}),addOverlapToSets(e),e.filter(isSet).sort(sortByTotalOverlap)),f=(r(t.shift(),{x:0,y:0}),e.filter(function(e){return 2===e.sets.length}));return t.forEach(function(e){const o=e.circle;if(o){const l=o.r,c=e.overlapping;var t=a.reduce((r,e,t)=>{const n=e.circle;if(!n||!c)return r;e=c[e.sets[0]];const s=getDistanceBetweenCirclesByOverlap(l,n.r,e);let i=[{x:n.x+s,y:n.y},{x:n.x-s,y:n.y},{x:n.x,y:n.y+s},{x:n.x,y:n.y-s}];return a.slice(t+1).forEach(function(e){var t=e.circle,e=c[e.sets[0]];t&&(e=getDistanceBetweenCirclesByOverlap(l,t.r,e),i=i.concat(getCircleCircleIntersection({x:n.x,y:n.y,r:s},{x:t.x,y:t.y,r:e})))}),i.forEach(function(e){o.x=e.x,o.y=e.y;var t=loss(u,f);t<r.loss&&(r.loss=t,r.coordinates=e)}),r},{loss:Number.MAX_VALUE,coordinates:void 0});r(e,t.coordinates)}}),u}function loss(n,e){return e.reduce(function(e,t){let r=0;return 1<t.sets.length&&(t=t.value-getOverlapBetweenCircles(t.sets.map(function(e){return n[e]})),r=Math.round(t*t*1e11)/1e11),e+r},0)}function nelderMead(i,e){function t(e,t){return e.fx-t.fx}const o=(r,e,n,s)=>e.map((e,t)=>r*e+n*s[t]);var r=(e,t)=>(t.fx=i(t),e[e.length-1]=t,e),n=e=>{const r=e[0];return e.map(e=>{const t=o(.5,r,.5,e);return t.fx=i(t),t})},s=(e,t,r,n)=>{const s=o(r,e,n,t);return s.fx=i(s),s};let l=(t=>{const r=t.length,n=new Array(r+1);n[0]=t,n[0].fx=i(t);for(let e=0;e<r;++e){const s=t.slice();s[e]=s[e]?1.05*s[e]:.001,s.fx=i(s),n[e+1]=s}return n})(e);for(let e=0;e<100;e++){l.sort(t);var c=l[l.length-1],a=getCentroid(l),u=s(a,c,2,-1);if(u.fx<l[0].fx){var f=s(a,c,3,-2);l=r(l,f.fx<u.fx?f:u)}else if(u.fx>=l[l.length-2].fx){let e;l=u.fx>c.fx?(e=s(a,c,.5,.5)).fx<c.fx?r(l,e):n(l):(e=s(a,c,1.5,-.5)).fx<u.fx?r(l,e):n(l)}else l=r(l,u)}return l[0]}function processVennData(e,i){const t=isArray(e)?e:[],r=t.reduce(function(e,t){return t.sets&&isValidSet(t)&&-1===e.indexOf(t.sets[0])&&e.push(t.sets[0]),e},[]).sort(),n=t.reduce(function(e,t){return t.sets&&isValidRelation(t)&&!t.sets.some(function(e){return-1===r.indexOf(e)})&&(e[t.sets.sort().join(i)]={sets:t.sets,value:t.value||0}),e},{});return r.reduce(function(t,r,e,n){const s=n.slice(e+1);return s.forEach(function(e){t.push(r+i+e)}),t},[]).forEach(function(e){var t;n[e]||(t={sets:e.split(i),value:0},n[e]=t)}),Object.keys(n).map(function(e){return n[e]})}function sortByTotalOverlap(e,t){return void 0!==t.totalOverlap&&void 0!==e.totalOverlap?t.totalOverlap-e.totalOverlap:NaN}const VennUtils={geometry:GU,geometryCircles:CU,addOverlapToSets:addOverlapToSets,getCentroid:getCentroid,getDistanceBetweenCirclesByOverlap:getDistanceBetweenCirclesByOverlap,getLabelWidth:getLabelWidth,getMarginFromCircles:getMarginFromCircles,isSet:isSet,layoutGreedyVenn:layoutGreedyVenn,loss:loss,nelderMead:nelderMead,processVennData:processVennData,sortByTotalOverlap:sortByTotalOverlap};export default VennUtils;