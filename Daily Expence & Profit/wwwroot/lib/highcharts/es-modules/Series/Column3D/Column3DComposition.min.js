"use strict";import ColumnSeries from"../Column/ColumnSeries.js";const columnProto=ColumnSeries["prototype"];import Series from"../../Core/Series/Series.js";import Math3D from"../../Core/Math3D.js";const perspective=Math3D["perspective"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";import StackItem from"../../Core/Axis/Stacking/StackItem.js";import U from"../../Core/Utilities.js";const{addEvent,extend,pick,wrap}=U;function retrieveStacks(t,i){const e=t.series,s={totalStacks:0};let o,r=1;return e.forEach(function(t){o=pick(t.options.stack,i?0:e.length-1-t.index),s[o]?s[o].series.push(t):(s[o]={series:[t],position:r},r++)}),s.totalStacks=r+1,s}function pointAttribs(t){const i=t.apply(this,[].slice.call(arguments,1));return this.chart.is3d&&this.chart.is3d()&&(i.stroke=this.options.edgeColor||i.fill,i["stroke-width"]=pick(this.options.edgeWidth,1)),i}function setState(t,i,e){var s=this.chart.is3d&&this.chart.is3d();s&&(this.options.inactiveOtherPoints=!0),t.call(this,i,e),s&&(this.options.inactiveOtherPoints=!1)}function hasNewShapeType(t,...i){return this.series.chart.is3d()?this.graphic&&"g"!==this.graphic.element.nodeName:t.apply(this,i)}if(wrap(columnProto,"translate",function(t){t.apply(this,[].slice.call(arguments,1)),this.chart.is3d()&&this.translate3dShapes()}),wrap(Series.prototype,"justifyDataLabel",function(t){return!arguments[2].outside3dPlot&&t.apply(this,[].slice.call(arguments,1))}),columnProto.translate3dPoints=function(){},columnProto.translate3dShapes=function(){let a=this,p=a.chart,t=a.options,h=t.depth,i=t.stacking?t.stack||0:a.index,n=i*(h+(t.groupZPadding||1)),c=a.borderWidth%2?.5:0,l;p.inverted&&!a.yAxis.reversed&&(c*=-1),!1!==t.grouping&&(n=0),n+=t.groupZPadding||1,a.data.forEach(function(s){if((s.outside3dPlot=null)!==s.y){const o=extend({x:0,y:0,width:0,height:0},s.shapeArgs||{}),i=[["x","width"],["y","height"]],r=s.tooltipPos;let e;var t;i.forEach(t=>{if((e=o[t[0]]-c)<0&&(o[t[1]]+=o[t[0]]+c,o[t[0]]=-c,e=0),e+o[t[1]]>a[t[0]+"Axis"].len&&0!==o[t[1]]&&(o[t[1]]=a[t[0]+"Axis"].len-o[t[0]]),0!==o[t[1]]&&(o[t[0]]>=a[t[0]+"Axis"].len||o[t[0]]+o[t[1]]<=c)){for(const i in o)o[i]="y"===i?-9999:0;s.outside3dPlot=!0}}),"roundedRect"===s.shapeType&&(s.shapeType="cuboid"),s.shapeArgs=extend(o,{z:n,depth:h,insidePlotArea:!0}),l={x:o.x+o.width/2,y:o.y,z:n+h/2},p.inverted&&(l.x=o.height,l.y=s.clientX||0),s.plot3d=perspective([l],p,!0,!1)[0],r&&(t=perspective([{x:r[0],y:r[1],z:n+h/2}],p,!0,!1)[0],s.tooltipPos=[t.x,t.y])}}),a.z=n},wrap(columnProto,"animate",function(t){if(this.chart.is3d()){const i=arguments,e=i[1],s=this.yAxis,o=this,r=this.yAxis.reversed;e?o.data.forEach(function(t){null!==t.y&&(t.height=t.shapeArgs.height,t.shapey=t.shapeArgs.y,t.shapeArgs.height=1,r||(t.stackY?t.shapeArgs.y=t.plotY+s.translate(t.stackY):t.shapeArgs.y=t.plotY+(t.negative?-t.height:t.height)))}):(o.data.forEach(function(t){null!==t.y&&(t.shapeArgs.height=t.height,t.shapeArgs.y=t.shapey,t.graphic&&t.graphic[t.outside3dPlot?"attr":"animate"](t.shapeArgs,o.options.animation))}),this.drawDataLabels())}else t.apply(this,[].slice.call(arguments,1))}),wrap(columnProto,"plotGroup",function(t,i,e,s,o,r){return"dataLabelsGroup"!==i&&"markerGroup"!==i&&this.chart.is3d()&&(this[i]&&delete this[i],r&&(this.chart.columnGroup||(this.chart.columnGroup=this.chart.renderer.g("columnGroup").add(r)),this[i]=this.chart.columnGroup,this.chart.columnGroup.attr(this.getPlotBox()),this[i].survive=!0,"group"===i&&(arguments[3]="visible"))),t.apply(this,Array.prototype.slice.call(arguments,1))}),wrap(columnProto,"setVisible",function(t,i){const e=this;e.chart.is3d()&&e.data.forEach(function(t){t.visible=t.options.visible=i=void 0===i?!pick(e.visible,t.visible):i,e.options.data[e.data.indexOf(t)]=t.options,t.graphic&&t.graphic.attr({visibility:i?"visible":"hidden"})}),t.apply(this,Array.prototype.slice.call(arguments,1))}),addEvent(ColumnSeries,"afterInit",function(){if(this.chart.is3d()){let s=this.options,t=s.grouping,o=s.stacking,r=this.yAxis.options.reversedStacks,a=0;if(void 0===t||t){let t=retrieveStacks(this.chart,o),i=s.stack||0,e;for(e=0;e<t[i].series.length&&t[i].series[e]!==this;e++);a=10*(t.totalStacks-t[i].position)+(r?e:-e),this.xAxis.reversed||(a=10*t.totalStacks-a)}s.depth=s.depth||25,this.z=this.z||0,s.zIndex=a}}),wrap(columnProto,"pointAttribs",pointAttribs),wrap(columnProto,"setState",setState),wrap(columnProto.pointClass.prototype,"hasNewShapeType",hasNewShapeType),SeriesRegistry.seriesTypes.columnRange){const ha=SeriesRegistry.seriesTypes.columnrange.prototype;wrap(ha,"pointAttribs",pointAttribs),wrap(ha,"setState",setState),wrap(ha.pointClass.prototype,"hasNewShapeType",hasNewShapeType),ha.plotGroup=columnProto.plotGroup,ha.setVisible=columnProto.setVisible}wrap(Series.prototype,"alignDataLabel",function(t,i,e,s,o){const r=this.chart;if(s.outside3dPlot=i.outside3dPlot,r.is3d()&&this.is("column")){var a=this.options,s=pick(s.inside,!!this.options.stacking),p=r.options.chart.options3d,h=i.pointWidth/2||0;let t={x:o.x+h,y:o.y,z:this.z+a.depth/2};r.inverted&&(s&&(o.width=0,t.x+=i.shapeArgs.height/2),90<=p.alpha&&p.alpha<=270&&(t.y+=i.shapeArgs.width)),t=perspective([t],r,!0,!1)[0],o.x=t.x-h,o.y=i.outside3dPlot?-9e9:t.y}t.apply(this,[].slice.call(arguments,1))}),wrap(StackItem.prototype,"getStackBox",function(i,e){const s=i.apply(this,[].slice.call(arguments,1)),o=this.axis.chart,r=e["width"];if(o.is3d()&&this.base){i=+this.base.split(",")[0],e=o.series[i],i=o.options.chart.options3d;if(e&&e instanceof SeriesRegistry.seriesTypes.column){let t={x:s.x+(o.inverted?s.height:r/2),y:s.y,z:e.options.depth/2};o.inverted&&(s.width=0,90<=i.alpha&&i.alpha<=270&&(t.y+=r)),t=perspective([t],o,!0,!1)[0],s.x=t.x-r/2,s.y=t.y}}return s});export default ColumnSeries;