"use strict";import Axis from"../../Core/Axis/Axis.js";import Chart from"../../Core/Chart/Chart.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,line:LineSeries}=SeriesRegistry["seriesTypes"];import U from"../../Core/Utilities.js";const{addEvent,arrayMax,arrayMin,correctFloat,extend,isNumber,merge,objectEach,pick}=U;import WaterfallAxis from"../../Core/Axis/WaterfallAxis.js";import WaterfallPoint from"./WaterfallPoint.js";function ownProp(t,e){return Object.hasOwnProperty.call(t,e)}class WaterfallSeries extends ColumnSeries{constructor(){super(...arguments),this.chart=void 0,this.data=void 0,this.options=void 0,this.points=void 0,this.stackedYNeg=void 0,this.stackedYPos=void 0,this.stackKey=void 0,this.xData=void 0,this.yAxis=void 0,this.yData=void 0}generatePoints(){ColumnSeries.prototype.generatePoints.apply(this);for(let t=0,e=this.points.length;t<e;t++){const a=this.points[t],s=this.processedYData[t];isNumber(s)&&(a.isIntermediateSum||a.isSum)&&(a.y=correctFloat(s))}}processData(t){let e=this,a=e.options,s=e.yData,i=a.data,o,r=s.length,l=a.threshold||0,h,n,d,p,c,u;for(n=h=d=p=0,u=0;u<r;u++)c=s[u],o=i&&i[u]?i[u]:{},"sum"===c||o.isSum?s[u]=correctFloat(n):"intermediateSum"===c||o.isIntermediateSum?(s[u]=correctFloat(h),h=0):(n+=c,h+=c),d=Math.min(n,d),p=Math.max(n,p);super.processData.call(this,t),a.stacking||(e.dataMin=d+l,e.dataMax=p)}toYData(t){return t.isSum?"sum":t.isIntermediateSum?"intermediateSum":t.y}updateParallelArrays(t,e){super.updateParallelArrays.call(this,t,e),"sum"!==this.yData[0]&&"intermediateSum"!==this.yData[0]||(this.yData[0]=null)}pointAttribs(t,e){var a=this.options.upColor;a&&!t.options.color&&isNumber(t.y)&&(t.color=0<t.y?a:void 0);const s=ColumnSeries.prototype.pointAttribs.call(this,t,e);return delete s.dashstyle,s}getGraphPath(){return[["M",0,0]]}getCrispPath(){let t=this.data.filter(t=>isNumber(t.y)),a=this.yAxis,s=t.length,i=Math.round(this.graph.strokeWidth())%2/2,o=Math.round(this.borderWidth)%2/2,r=this.xAxis.reversed,l=this.yAxis.reversed,h=this.options.stacking,n=[];for(let e=1;e<s;e++)if(this.options.connectNulls||isNumber(this.data[t[e].index-1].y)){var d=t[e].box,p=t[e-1],c=p.y||0,u=t[e-1].box;if(d&&u){var g=a.waterfall.stacks[this.stackKey],y=0<c?-u.height:0;if(g&&u&&d){var g=g[e-1];let t;t=h?(g=g.connectorThreshold,Math.round(a.translate(g,!1,!0,!1,!0)+(l?y:0))-i):u.y+p.minPointLengthOffset+o-i,n.push(["M",(u.x||0)+(!r&&u.width||0),t],["L",(d.x||0)+(r&&d.width||0),t])}if(u&&n.length&&(!h&&c<0&&!l||0<c&&l)){const m=n[n.length-2],f=(m&&"number"==typeof m[2]&&(m[2]+=u.height||0),n[n.length-1]);f&&"number"==typeof f[2]&&(f[2]+=u.height||0)}}}return n}drawGraph(){LineSeries.prototype.drawGraph.call(this),this.graph&&this.graph.attr({d:this.getCrispPath()})}setStackedPoints(){let e=this,a=e.options,t=e.yAxis.waterfall.stacks,s=a.threshold||0,i=s,o=i,r=e.stackKey,l=e.xData,h=l.length,n,d,p,c,u,g,y,m,f,b,x,S;function k(t,e,a,s){if(n){if(u)for(;a<u;a++)n.stackState[a]+=s;else n.stackState[0]=t,u=n.stackState.length;n.stackState.push(n.stackState[u-1]+e)}}if(e.yAxis.stacking.usePercentage=!1,d=p=c=i,e.visible||!e.chart.options.chart.ignoreHiddenSeries){S=t.changed,(x=t.alreadyChanged)&&x.indexOf(r)<0&&(S=!0),t[r]||(t[r]={});const P=t[r];if(P)for(let t=0;t<h;t++)b=l[t],P[b]&&!S||(P[b]={negTotal:0,posTotal:0,stackTotal:0,threshold:0,stateIndex:0,stackState:[],label:S&&P[b]?P[b].label:void 0}),n=P[b],0<=(f=e.yData[t])?n.posTotal+=f:n.negTotal+=f,m=a.data[t],g=n.absolutePos=n.posTotal,y=n.absoluteNeg=n.negTotal,n.stackTotal=g+y,u=n.stackState.length,m&&m.isIntermediateSum?(k(c,p,0,c),c=p,p=s,i^=o,o^=i,i^=o):m&&m.isSum?(k(s,d,u,0),i=s):(k(i,f,0,d),m&&(d+=f,p+=f)),n.stateIndex++,n.threshold=i,i+=n.stackTotal;t.changed=!1,t.alreadyChanged||(t.alreadyChanged=[]),t.alreadyChanged.push(r)}}getExtremes(){let t=this.options.stacking,e,a,s;return t?(e=this.yAxis.waterfall.stacks,a=this.stackedYNeg=[],s=this.stackedYPos=[],"overlap"===t?objectEach(e[this.stackKey],function(t){a.push(arrayMin(t.stackState)),s.push(arrayMax(t.stackState))}):objectEach(e[this.stackKey],function(t){a.push(t.negTotal+t.threshold),s.push(t.posTotal+t.threshold)}),{dataMin:arrayMin(a),dataMax:arrayMax(s)}):{dataMin:this.dataMin,dataMax:this.dataMax}}}WaterfallSeries.defaultOptions=merge(ColumnSeries.defaultOptions,{dataLabels:{inside:!0},lineWidth:1,lineColor:"#333333",dashStyle:"Dot",borderColor:"#333333",states:{hover:{lineWidthPlus:0}}}),addEvent(WaterfallSeries,"afterColumnTranslate",function(){const e=this,{options:t,points:a,yAxis:s}=e,i=pick(t.minPointLength,5),o=i/2,r=t.threshold||0,l=t.stacking,h=s.waterfall.stacks[e.stackKey];let n=r,d=r,p,c,u,g;for(let t=0;t<a.length;t++){const f=a[t],b=e.processedYData[t],x=f.shapeArgs,S=extend({x:0,y:0,width:0,height:0},x||{});f.box=S;var y=[0,b],m=f.y||0;if(l){if(h){const k=h[t],P=("overlap"===l?(c=k.stackState[k.stateIndex--],p=0<=m?c:c-m,ownProp(k,"absolutePos")&&delete k.absolutePos,ownProp(k,"absoluteNeg")&&delete k.absoluteNeg):(p=0<=m?(c=k.threshold+k.posTotal,k.posTotal-=m,c):(c=k.threshold+k.negTotal,k.negTotal-=m,c-m),k.posTotal||isNumber(k.absolutePos)&&ownProp(k,"absolutePos")&&(k.posTotal=k.absolutePos,delete k.absolutePos),k.negTotal||isNumber(k.absoluteNeg)&&ownProp(k,"absoluteNeg")&&(k.negTotal=k.absoluteNeg,delete k.absoluteNeg)),f.isSum||(k.connectorThreshold=k.threshold+k.stackTotal),g=s.reversed?(u=0<=m?p-m:p+m,p):(u=p)-m,f.below=u<=r,S.y=s.translate(u,!1,!0,!1,!0),S.height=Math.abs(S.y-s.translate(g,!1,!0,!1,!0)),s.waterfall.dummyStackItem);P&&(P.x=t,P.label=h[t].label,P.setOffset(e.pointXOffset||0,e.barW||0,e.stackedYNeg[t],e.stackedYPos[t],void 0,this.xAxis))}}else p=Math.max(d,d+m)+y[0],S.y=s.translate(p,!1,!0,!1,!0),f.isSum?(S.y=s.translate(y[1],!1,!0,!1,!0),S.height=Math.min(s.translate(y[0],!1,!0,!1,!0),s.len)-S.y,f.below=y[1]<=r):f.isIntermediateSum?(g=0<=m?(u=y[1]+n,n):(u=n,y[1]+n),s.reversed&&(u^=g,g^=u,u^=g),S.y=s.translate(u,!1,!0,!1,!0),S.height=Math.abs(S.y-Math.min(s.translate(g,!1,!0,!1,!0),s.len)),n+=y[1],f.below=u<=r):(S.height=0<b?s.translate(d,!1,!0,!1,!0)-S.y:s.translate(d,!1,!0,!1,!0)-s.translate(d-b,!1,!0,!1,!0),d+=b,f.below=d<r),S.height<0&&(S.y+=S.height,S.height*=-1);f.plotY=S.y=Math.round(S.y||0)-e.borderWidth%2/2,S.height=Math.max(Math.round(S.height||0),.001),f.yBottom=S.y+S.height,S.height<=i&&!f.isNull?(S.height=i,S.y-=o,f.plotY=S.y,f.minPointLengthOffset=m<0?-o:o):(f.isNull&&(S.width=0),f.minPointLengthOffset=0);y=f.plotY+(f.negative?S.height:0);f.below&&(f.plotY+=S.height),f.tooltipPos&&(e.chart.inverted?f.tooltipPos[0]=s.len-y:f.tooltipPos[1]=y),f.isInside=this.isPointInside(f),merge(!0,f.shapeArgs,S)}},{order:2}),extend(WaterfallSeries.prototype,{getZonesGraphs:LineSeries.prototype.getZonesGraphs,pointValKey:"y",showLine:!0,pointClass:WaterfallPoint}),SeriesRegistry.registerSeriesType("waterfall",WaterfallSeries),WaterfallAxis.compose(Axis,Chart);export default WaterfallSeries;