"use strict";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{pie:PieSeries}=SeriesRegistry["seriesTypes"];import U from"../../Core/Utilities.js";const{arrayMax,arrayMin,clamp,extend,fireEvent,merge,pick}=U;class VariablePieSeries extends PieSeries{constructor(){super(...arguments),this.data=void 0,this.options=void 0,this.points=void 0,this.radii=void 0}calculateExtremes(){let e=this,t=e.chart,i=t.plotWidth,a=t.plotHeight,r=e.options,s=2*(r.slicedOffset||0),n,l,o=e.zData,h=Math.min(i,a)-s,p={},c=e.center||e.getCenter();["minPointSize","maxPointSize"].forEach(function(e){var t=r[e],i=/%$/.test(t),t=parseInt(t,10);p[e]=i?h*t/100:2*t}),e.minPxSize=c[3]+p.minPointSize,e.maxPxSize=clamp(c[2],c[3]+p.minPointSize,p.maxPointSize),o.length&&(n=pick(r.zMin,arrayMin(o.filter(e.zValEval))),l=pick(r.zMax,arrayMax(o.filter(e.zValEval))),this.getRadii(n,l,e.minPxSize,e.maxPxSize))}getRadii(e,t,i,a){let r=0,s,n=this.zData,l=n.length,o=[],h=this.options,p="radius"!==h.sizeBy,c=t-e,d,M;for(r;r<l;r++)d=this.zValEval(n[r])?n[r]:e,M=d<=e?i/2:t<=d?a/2:(s=0<c?(d-e)/c:.5,p&&(s=Math.sqrt(s)),Math.ceil(i+s*(a-i))/2),o.push(M);this.radii=o}redraw(){this.center=null,super.redraw.apply(this,arguments)}translate(e){this.generatePoints();let t=this,i=0,a=1e3,r=t.options,s=r.slicedOffset,n=s+(r.borderWidth||0),l,o,h,p,c=r.startAngle||0,d=Math.PI/180*(c-90),M=Math.PI/180*(pick(r.endAngle,c+360)-90),P=M-d,m=t.points,g,x,z=r.dataLabels.distance,S=r.ignoreHiddenPoint,y,b=m.length,u,f,v,V;for(t.startAngleRad=d,t.endAngleRad=M,t.calculateExtremes(),e||(t.center=e=t.getCenter()),y=0;y<b;y++)u=m[y],f=t.radii[y],u.labelDistance=pick(u.options.dataLabels&&u.options.dataLabels.distance,z),t.maxLabelDistance=Math.max(t.maxLabelDistance||0,u.labelDistance),o=d+i*P,S&&!u.visible||(i+=u.percentage/100),h=d+i*P,u.shapeType="arc",u.shapeArgs={x:e[0],y:e[1],r:f,innerR:e[3]/2,start:Math.round(o*a)/a,end:Math.round(h*a)/a},(p=(h+o)/2)>1.5*Math.PI?p-=2*Math.PI:p<-Math.PI/2&&(p+=2*Math.PI),u.slicedTranslation={translateX:Math.round(Math.cos(p)*s),translateY:Math.round(Math.sin(p)*s)},g=Math.cos(p)*e[2]/2,x=Math.sin(p)*e[2]/2,v=Math.cos(p)*f,V=Math.sin(p)*f,u.tooltipPos=[e[0]+.7*g,e[1]+.7*x],u.half=p<-Math.PI/2||p>Math.PI/2?1:0,u.angle=p,l=Math.min(n,u.labelDistance/5),u.labelPosition={natural:{x:e[0]+v+Math.cos(p)*u.labelDistance,y:e[1]+V+Math.sin(p)*u.labelDistance},computed:{},alignment:u.half?"right":"left",connectorPosition:{breakAt:{x:e[0]+v+Math.cos(p)*l,y:e[1]+V+Math.sin(p)*l},touchingSliceAt:{x:e[0]+v,y:e[1]+V}}};fireEvent(t,"afterTranslate")}zValEval(e){return"number"==typeof e&&!isNaN(e)||null}}VariablePieSeries.defaultOptions=merge(PieSeries.defaultOptions,{minPointSize:"10%",maxPointSize:"100%",zMin:void 0,zMax:void 0,sizeBy:"area",tooltip:{pointFormat:'<span style="color:{point.color}">‚óè</span> {series.name}<br/>Value: {point.y}<br/>Size: {point.z}<br/>'}}),extend(VariablePieSeries.prototype,{pointArrayMap:["y","z"],parallelArrays:["x","y","z"]}),SeriesRegistry.registerSeriesType("variablepie",VariablePieSeries);export default VariablePieSeries;