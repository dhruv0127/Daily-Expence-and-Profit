"use strict";import A from"../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import Chart from"../Core/Chart/Chart.js";import D from"../Core/Defaults.js";const defaultOptions=D["defaultOptions"];import Point from"../Core/Series/Point.js";import Series from"../Core/Series/Series.js";import SeriesRegistry from"../Core/Series/SeriesRegistry.js";const seriesTypes=SeriesRegistry["seriesTypes"];import SVGRenderer from"../Core/Renderer/SVG/SVGRenderer.js";const{symbols}=SVGRenderer["prototype"];import U from"../Core/Utilities.js";const{addEvent,defined,error,isArray,isFunction,isObject,isNumber,merge,objectEach,relativeLength,syncTimeout}=U;import Axis from"../Core/Axis/Axis.js";const Scatter=seriesTypes.scatter,baseGeneratePoints=Series.prototype.generatePoints;let oldPointsStateId=[],stateIdCounter=0;const clusterDefaultOptions={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},pixelsToValues=((defaultOptions.plotOptions||{}).series=merge((defaultOptions.plotOptions||{}).series,{cluster:clusterDefaultOptions,tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}),(t,e)=>{const{chart:a,xAxis:i,yAxis:o}=t;return a.mapView?a.mapView.pixelsToProjectedUnits(e):{x:i?i.toValue(e.x):0,y:o?o.toValue(e.y):0}}),valuesToPixels=(t,e)=>{const{chart:a,xAxis:i,yAxis:o}=t;return a.mapView?a.mapView.projectedUnitsToPixels(e):{x:i?i.toPixels(e.x):0,y:o?o.toPixels(e.y):0}};function getClusterPosition(t){let e=t.length,a=0,i=0,o;for(o=0;o<e;o++)a+=t[o].x,i+=t[o].y;return{x:a/e,y:i/e}}function getDataState(t,e){const a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function fadeInElement(t,e,a){t.attr({opacity:e}).animate({opacity:1},a)}function fadeInStatePoint(t,e,a,i,o){t.point&&(i&&t.point.graphic&&(t.point.graphic.show(),fadeInElement(t.point.graphic,e,a)),o&&t.point.dataLabel&&(t.point.dataLabel.show(),fadeInElement(t.point.dataLabel,e,a)))}function hideStatePoint(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function destroyOldPoints(t){t&&objectEach(t,function(t){t.point&&t.point.destroy&&t.point.destroy()})}function fadeInNewPointAndDestoryOld(t,e,a,i){fadeInStatePoint(t,i,a,!0,!0),e.forEach(function(t){t.point&&t.point.destroy&&t.point.destroy()})}function getStateId(){return Math.random().toString(36).substring(2,7)+"-"+stateIdCounter++}symbols.cluster=function(t,e,a,i){const o=a/2,r=i/2,s=symbols.arc(t+o,e+r,o-4,r-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),n=symbols.arc(t+o,e+r,o-3,r-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:o-2,open:!1}),l=symbols.arc(t+o,e+r,o-1,r-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:o,open:!1});return l.concat(n,s)},Scatter.prototype.animateClusterPoint=function(t){const e=this.chart,a=e.mapView,i=this.options.cluster,o=animObject((i||{}).animation),r=o.duration||500,s=(this.markerClusterInfo||{}).pointsState,n=(s||{}).newState,l=(s||{}).oldState,p=[];let d,u,c,h,m,f,g,x=!1,y=!1;var S;l&&n&&(c=n[t.stateId],S=valuesToPixels(this,c),f=S.x-(a?0:e.plotLeft),g=S.y-(a?0:e.plotTop),1===c.parentsId.length?(d=(n||{})[t.stateId].parentsId[0],u=l[d],c.point&&c.point.graphic&&u&&u.point&&u.point.plotX&&u.point.plotY&&u.point.plotX!==c.point.plotX&&u.point.plotY!==c.point.plotY&&(h=c.point.graphic.getBBox(),m=c.point.graphic&&c.point.graphic.isImg?0:h.width/2,c.point.graphic.attr({x:u.point.plotX-m,y:u.point.plotY-m}),c.point.graphic.animate({x:f-(c.point.graphic.radius||0),y:g-(c.point.graphic.radius||0)},o,function(){y=!0,u.point&&u.point.destroy&&u.point.destroy()}),c.point.dataLabel&&c.point.dataLabel.alignAttr&&u.point.dataLabel&&u.point.dataLabel.alignAttr&&(c.point.dataLabel.attr({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y}),c.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y},o)))):0===c.parentsId.length?(hideStatePoint(c,!0,!0),syncTimeout(function(){fadeInStatePoint(c,.1,o,!0,!0)},r/2)):(hideStatePoint(c,!0,!0),c.parentsId.forEach(function(t){l&&l[t]&&(u=l[t],p.push(u),u.point&&u.point.graphic&&(x=!0,u.point.graphic.show(),u.point.graphic.animate({x:f-(u.point.graphic.radius||0),y:g-(u.point.graphic.radius||0),opacity:.4},o,function(){y=!0,fadeInNewPointAndDestoryOld(c,p,o,.7)}),u.point.dataLabel&&-9999!==u.point.dataLabel.y&&c.point&&c.point.dataLabel&&c.point.dataLabel.alignAttr&&(u.point.dataLabel.show(),u.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y,opacity:.4},o))))}),syncTimeout(function(){y||fadeInNewPointAndDestoryOld(c,p,o,.85)},r),x||syncTimeout(function(){fadeInNewPointAndDestoryOld(c,p,o,.1)},r/2)))},Scatter.prototype.getGridOffset=function(){let t=this,e=t.chart,a=t.xAxis,i=t.yAxis,o=0,r=0;return o=a&&t.dataMinX&&t.dataMaxX?a.reversed?a.toPixels(t.dataMaxX):a.toPixels(t.dataMinX):e.plotLeft,r=i&&t.dataMinY&&t.dataMaxY?i.reversed?i.toPixels(t.dataMinY):i.toPixels(t.dataMaxY):e.plotTop,{plotLeft:o,plotTop:r}},Scatter.prototype.getScaledGridSize=function(t){const e=this,a=e.xAxis,i=this.chart.mapView,o=t.processedGridSize||clusterDefaultOptions.layoutAlgorithm.gridSize;let r=!0,s=1,n=1;e.gridValueSize||(i?e.gridValueSize=o/i.getScale():e.gridValueSize=Math.abs(a.toValue(o)-a.toValue(0)));for(var l=+(o/(i?e.gridValueSize*i.getScale():a.toPixels(e.gridValueSize)-a.toPixels(0))).toFixed(14);r&&1!=l;){var p=Math.pow(2,s);.75<l&&l<1.25?r=!1:1/p<=l&&l<1/p*2?(r=!1,n=p):l<=p&&p/2<l&&(r=!1,n=1/p),s++}return o/n/l},Scatter.prototype.getRealExtremes=function(){var t=this.chart,e=t.mapView?0:t.plotLeft,a=t.mapView?0:t.plotTop,a=pixelsToValues(this,{x:e,y:a}),e=pixelsToValues(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=a.x,i=e.x,a=a.y,e=e.y;return{minX:Math.min(t,i),maxX:Math.max(t,i),minY:Math.min(a,e),maxY:Math.max(a,e)}},Scatter.prototype.onDrillToCluster=function(t){const e=t.point||t.target;e.firePointEvent("drillToCluster",t,function(t){const e=t.point||t.target,a=e.series,i=e.series.xAxis,o=e.series.yAxis,r=e.series.chart,s=r.mapView,n=a.options.cluster,l=(n||{}).drillToCluster;var p,d,u,c,h,m,f;l&&e.clusteredData&&(m=e.clusteredData.map(t=>t.x).sort((t,e)=>t-e),d=e.clusteredData.map(t=>t.y).sort((t,e)=>t-e),h=m[0],m=m[m.length-1],p=d[0],d=d[d.length-1],f=Math.abs(.1*(m-h)),u=Math.abs(.1*(d-p)),c=Math.min(h,m)-f,h=Math.max(h,m)+f,m=Math.min(p,d)-u,f=Math.max(p,d)+u,s?s.fitToBounds({x1:c,x2:h,y1:m,y2:f}):i&&o&&(r.pointer.zoomX=!0,r.pointer.zoomY=!0,r.zoom({originalEvent:t,xAxis:[{axis:i,min:c,max:h}],yAxis:[{axis:o,min:m,max:f}]})))})},Scatter.prototype.getClusterDistancesFromPoint=function(e,a,i){const o=[];for(let t=0;t<e.length;t++){var r=valuesToPixels(this,{x:a,y:i}),s=valuesToPixels(this,{x:e[t].posX,y:e[t].posY}),r=Math.sqrt(Math.pow(r.x-s.x,2)+Math.pow(r.y-s.y,2));o.push({clusterIndex:t,distance:r})}return o.sort((t,e)=>t.distance-e.distance)},Scatter.prototype.getPointsState=function(t,e,a){let i=e?getDataState(e,a):[],o=getDataState(t,a),r={},s,n,l;for(oldPointsStateId=[],t.clusters.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),l=0;l<o.length;l++)s=o[l],n=i[l],s&&n&&s.parentStateId&&n.parentStateId&&r[s.parentStateId]&&-1===r[s.parentStateId].parentsId.indexOf(n.parentStateId)&&(r[s.parentStateId].parentsId.push(n.parentStateId),-1===oldPointsStateId.indexOf(n.parentStateId)&&oldPointsStateId.push(n.parentStateId));return r},Scatter.prototype.markerClusterAlgorithms={grid:function(t,e,a,i){const o={},r=this.getGridOffset();let s,n,l,p,d;var u=this.getScaledGridSize(i);for(d=0;d<t.length;d++){var c=valuesToPixels(this,{x:t[d],y:e[d]});s=c.x-r.plotLeft,n=c.y-r.plotTop,l=Math.floor(s/u),p=Math.floor(n/u)+"-"+l,o[p]||(o[p]=[]),o[p].push({dataIndex:a[d],x:t[d],y:e[d]})}return o},kmeans:function(t,e,a,i){let o=this,r=[],s=[],n={},l=i.processedDistance||clusterDefaultOptions.layoutAlgorithm.distance,p=i.iterations,d=0,u=!0,c,h,m,f=[],g,x,y,S;for(x in i.processedGridSize=i.processedDistance,g=o.markerClusterAlgorithms?o.markerClusterAlgorithms.grid.call(o,t,e,a,i):{})1<g[x].length&&(m=getClusterPosition(g[x]),r.push({posX:m.x,posY:m.y,oldX:0,oldY:0,startPointsLen:g[x].length,points:[]}));for(;u;){for(r.map(t=>(t.points.length=0,t)),s.length=0,y=0;y<t.length;y++)c=t[y],h=e[y],((f=o.getClusterDistancesFromPoint(r,c,h)).length&&f[0].distance<l?r[f[0].clusterIndex].points:s).push({x:c,y:h,dataIndex:a[y]});for(S=0;S<r.length;S++)1===r[S].points.length&&(f=o.getClusterDistancesFromPoint(r,r[S].points[0].x,r[S].points[0].y))[1].distance<l&&(r[f[1].clusterIndex].points.push(r[S].points[0]),r[f[0].clusterIndex].points.length=0);for(u=!1,S=0;S<r.length;S++)m=getClusterPosition(r[S].points),r[S].oldX=r[S].posX,r[S].oldY=r[S].posY,r[S].posX=m.x,r[S].posY=m.y,(r[S].posX>r[S].oldX+1||r[S].posX<r[S].oldX-1||r[S].posY>r[S].oldY+1||r[S].posY<r[S].oldY-1)&&(u=!0);p&&(u=d<p-1),d++}return r.forEach(function(t,e){n["cluster"+e]=t.points}),s.forEach(function(t,e){n["noise"+e]=[t]}),n},optimizedKmeans:function(t,e,a,i){let o=this,r=i.processedDistance||clusterDefaultOptions.layoutAlgorithm.gridSize,s={},n=o.getRealExtremes(),l=(o.options.cluster||{}).marker,p,d,u;return!o.markerClusterInfo||o.initMaxX&&o.initMaxX<n.maxX||o.initMinX&&o.initMinX>n.minX||o.initMaxY&&o.initMaxY<n.maxY||o.initMinY&&o.initMinY>n.minY?(o.initMaxX=n.maxX,o.initMinX=n.minX,o.initMaxY=n.maxY,o.initMinY=n.minY,s=o.markerClusterAlgorithms?o.markerClusterAlgorithms.kmeans.call(o,t,e,a,i):{},o.baseClusters=null):(o.baseClusters||(o.baseClusters={clusters:o.markerClusterInfo.clusters,noise:o.markerClusterInfo.noise}),o.baseClusters.clusters.forEach(function(i){i.pointsOutside=[],i.pointsInside=[],i.data.forEach(function(t){var e=valuesToPixels(o,t),a=valuesToPixels(o,i);d=Math.sqrt(Math.pow(e.x-a.x,2)+Math.pow(e.y-a.y,2)),u=(i.clusterZone&&i.clusterZone.marker&&i.clusterZone.marker.radius?i.clusterZone.marker:l&&l.radius?l:clusterDefaultOptions.marker).radius,p=0<=r-u?r-u:u,d>u+p&&defined(i.pointsOutside)?i.pointsOutside.push(t):defined(i.pointsInside)&&i.pointsInside.push(t)}),i.pointsInside.length&&(s[i.id]=i.pointsInside),i.pointsOutside.forEach(function(t,e){s[i.id+"_noise"+e]=[t]})}),o.baseClusters.noise.forEach(function(t){s[t.id]=t.data})),s}},Scatter.prototype.preventClusterCollisions=function(t){let a=this,[i,o]=t.key.split("-").map(parseFloat),r=t.gridSize,s=t.groupedData,n=t.defaultRadius,l=t.clusterRadius,p=o*r,d=i*r,e=valuesToPixels(a,t),u=e.x,c=e.y,h=[],m,f=0,g=(a.options.cluster||{}).marker,x=(a.options.cluster||{}).zones,y=a.getGridOffset(),S,C,I,b,P,k,M,A,D,O,v,T,E;for(u-=y.plotLeft,c-=y.plotTop,M=1;M<5;M++)for(I=M%2?-1:1,b=M<3?-1:1,P=Math.floor((u+I*l)/r),E=[(k=Math.floor((c+b*l)/r))+"-"+P,k+"-"+o,i+"-"+P],A=0;A<E.length;A++)-1===h.indexOf(E[A])&&E[A]!==t.key&&h.push(E[A]);h.forEach(function(t){if(s[t]){s[t].posX||(v=getClusterPosition(s[t]),s[t].posX=v.x,s[t].posY=v.y);var e=valuesToPixels(a,{x:s[t].posX||0,y:s[t].posY||0});if(S=e.x-y.plotLeft,C=e.y-y.plotTop,[O,D]=t.split("-").map(parseFloat),x)for(m=s[t].length,M=0;M<x.length;M++)m>=x[M].from&&m<=x[M].to&&(f=defined((x[M].marker||{}).radius)?x[M].marker.radius||0:(g&&g.radius?g:clusterDefaultOptions.marker).radius);1<s[t].length&&0===f&&g&&g.radius?f=g.radius:1===s[t].length&&(f=n),T=l+f,f=0,D!==o&&Math.abs(u-S)<T&&(u=D-o<0?p+l:p+r-l),O!==i&&Math.abs(c-C)<T&&(c=O-i<0?d+l:d+r-l)}});var X=pixelsToValues(a,{x:u+y.plotLeft,y:c+y.plotTop});return s[t.key].posX=X.x,s[t.key].posY=X.y,X},Scatter.prototype.isValidGroupedDataObject=function(t){let e=!1,a;return!!isObject(t)&&(objectEach(t,function(t){if(e=!0,isArray(t)&&t.length){for(a=0;a<t.length;a++)if(!isObject(t[a])||!t[a].x||!t[a].y)return void(e=!1)}else e=!1}),e)},Scatter.prototype.getClusteredData=function(t,e){let a=this,i=[],o=[],r=[],s=[],n=[],l=0,p=Math.max(2,e.minimumClusterSize||2),d,u,c,h,m,f,g,x,y,S,C,I,b,P;if(isFunction(e.layoutAlgorithm.type)&&!a.isValidGroupedDataObject(t))return error("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,a.chart),!1;for(P in t)if(t[P].length>=p){if(c=t[P],d=getStateId(),m=c.length,e.zones)for(b=0;b<e.zones.length;b++)m>=e.zones[b].from&&m<=e.zones[b].to&&((C=e.zones[b]).zoneIndex=b,S=e.zones[b].marker,I=e.zones[b].className);for(y=getClusterPosition(c),g="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:y.x,y:y.y}:(f=a.options.marker||{},a.preventClusterCollisions({x:y.x,y:y.y,key:P,groupedData:t,gridSize:a.getScaledGridSize(e.layoutAlgorithm),defaultRadius:f.radius||3+(f.lineWidth||0),clusterRadius:S&&S.radius?S.radius:(e.marker||{}).radius||clusterDefaultOptions.marker.radius})),b=0;b<m;b++)c[b].parentStateId=d;if(r.push({x:g.x,y:g.y,id:P,stateId:d,index:l,data:c,clusterZone:C,clusterZoneClassName:I}),i.push(g.x),o.push(g.y),n.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:merge(e.marker,{states:e.states},S||{})}}),a.options.data&&a.options.data.length)for(b=0;b<m;b++)isObject(a.options.data[c[b].dataIndex])&&(c[b].options=a.options.data[c[b].dataIndex]);l++,S=null}else for(b=0;b<t[P].length;b++)u=t[P][b],d=getStateId(),x=null,h=((a.options||{}).data||[])[u.dataIndex],i.push(u.x),o.push(u.y),u.parentStateId=d,s.push({x:u.x,y:u.y,id:P,stateId:d,index:l,data:t[P]}),x=h&&"object"==typeof h&&!isArray(h)?merge(h,{x:u.x,y:u.y}):{userOptions:h,x:u.x,y:u.y},n.push({options:x}),l++;return{clusters:r,noise:s,groupedXData:i,groupedYData:o,groupMap:n}},Scatter.prototype.destroyClusteredData=function(){const t=this.markerClusterSeriesData;(t||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null},Scatter.prototype.hideClusteredData=function(){const t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=oldPointsStateId.map(t=>(e[t].point||{}).id||"");(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})},Scatter.prototype.generatePoints=function(){const a=this,t=a.chart,e=t.mapView,i=a.xData,o=a.yData,r=a.options.cluster,s=a.getRealExtremes(),n=[],l=[],p=[];let d,u,c,h,m,f,g,x,y,S,C,I,b,P,k,M,A;if(e&&a.is("mappoint")&&i&&o&&(a.options.data||[]).forEach((t,e)=>{t=a.projectPoint(t);t&&(i[e]=t.x,o[e]=t.y)}),r&&r.enabled&&i&&i.length&&o&&o.length&&!t.polar){C=r.layoutAlgorithm.type,(k=r.layoutAlgorithm).processedGridSize=relativeLength(k.gridSize||clusterDefaultOptions.layoutAlgorithm.gridSize,t.plotWidth),k.processedDistance=relativeLength(k.distance||clusterDefaultOptions.layoutAlgorithm.distance,t.plotWidth),h=k.kmeansThreshold||clusterDefaultOptions.layoutAlgorithm.kmeansThreshold;var D=k.processedGridSize/2,O=pixelsToValues(a,{x:0,y:0}),D=pixelsToValues(a,{x:D,y:D});for(m=Math.abs(O.x-D.x),f=Math.abs(O.y-D.y),A=0;A<i.length;A++)a.dataMaxX||(defined(x)&&defined(g)&&defined(S)&&defined(y)?isNumber(o[A])&&isNumber(S)&&isNumber(y)&&(x=Math.max(i[A],x),g=Math.min(i[A],g),S=Math.max(o[A]||S,S),y=Math.min(o[A]||y,y)):(x=g=i[A],S=y=o[A])),i[A]>=s.minX-m&&i[A]<=s.maxX+m&&(o[A]||s.minY)>=s.minY-f&&(o[A]||s.maxY)<=s.maxY+f&&(n.push(i[A]),l.push(o[A]),p.push(A));defined(x)&&defined(g)&&isNumber(S)&&isNumber(y)&&(a.dataMaxX=x,a.dataMinX=g,a.dataMaxY=S,a.dataMinY=y),b=(P=(I=isFunction(C)?C:a.markerClusterAlgorithms?C&&a.markerClusterAlgorithms[C]?a.markerClusterAlgorithms[C]:n.length<h?a.markerClusterAlgorithms.kmeans:a.markerClusterAlgorithms.grid:function(){return!1}).call(this,n,l,p,k))&&a.getClusteredData(P,r),d=r.animation&&a.markerClusterInfo&&a.markerClusterInfo.pointsState&&a.markerClusterInfo.pointsState.oldState?(destroyOldPoints(a.markerClusterInfo.pointsState.oldState),a.markerClusterInfo.pointsState.newState):{},u=i.length,c=a.markerClusterInfo,b&&(a.processedXData=b.groupedXData,a.processedYData=b.groupedYData,a.hasGroupedData=!0,a.markerClusterInfo=b,a.groupMap=b.groupMap),baseGeneratePoints.apply(this),b&&a.markerClusterInfo&&((a.markerClusterInfo.clusters||[]).forEach(function(t){(M=a.points[t.index]).isCluster=!0,M.clusteredData=t.data,M.clusterPointsAmount=t.data.length,t.point=M,addEvent(M,"click",a.onDrillToCluster)}),(a.markerClusterInfo.noise||[]).forEach(function(t){t.point=a.points[t.index]}),r.animation&&a.markerClusterInfo&&(a.markerClusterInfo.pointsState={oldState:d,newState:a.getPointsState(b,c,u)}),r.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else baseGeneratePoints.apply(this)},addEvent(Chart,"render",function(){(this.series||[]).forEach(function(e){var t,a;e.markerClusterInfo&&(t=e.options.cluster,a=((e.markerClusterInfo||{}).pointsState||{}).oldState,(t||{}).animation&&e.markerClusterInfo&&0===e.chart.pointer.pinchDown.length&&"pan"!==((e.xAxis||{}).eventArgs||{}).trigger&&a&&Object.keys(a).length&&(e.markerClusterInfo.clusters.forEach(function(t){e.animateClusterPoint(t)}),e.markerClusterInfo.noise.forEach(function(t){e.animateClusterPoint(t)})))})}),addEvent(Point,"update",function(){if(this.dataGroup)return error("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}),addEvent(Series,"destroy",Scatter.prototype.destroyClusteredData),addEvent(Series,"afterRender",function(){const e=(this.options.cluster||{}).drillToCluster;this.markerClusterInfo&&this.markerClusterInfo.clusters&&this.markerClusterInfo.clusters.forEach(function(t){t.point&&t.point.graphic&&(t.point.graphic.addClass("highcharts-cluster-point"),e&&t.point&&(t.point.graphic.css({cursor:"pointer"}),t.point.dataLabel&&t.point.dataLabel.css({cursor:"pointer"})),defined(t.clusterZone)&&t.point.graphic.addClass(t.clusterZoneClassName||"highcharts-cluster-zone-"+t.clusterZone.zoneIndex))})}),addEvent(Point,"drillToCluster",function(t){const e=t.point||t.target,a=e.series,i=a.options.cluster,o=((i||{}).events||{}).drillToCluster;isFunction(o)&&o.call(this,t)}),addEvent(Axis,"setExtremes",function(){let t=this.chart,e=0,a;t.series.forEach(function(t){t.markerClusterInfo&&(a=animObject((t.options.cluster||{}).animation),e=a.duration||0)}),syncTimeout(function(){t.tooltip&&t.tooltip.destroy()},e)});