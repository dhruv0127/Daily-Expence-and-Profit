"use strict";import Axis from"../Core/Axis/Axis.js";import Chart from"../Core/Chart/Chart.js";import F from"../Core/FormatUtilities.js";const format=F["format"];import H from"../Core/Globals.js";import D from"../Core/Defaults.js";const setOptions=D["setOptions"];import Series from"../Core/Series/Series.js";import U from"../Core/Utilities.js";const{addEvent,arrayMax,arrayMin,defined,erase,extend,isArray,isNumber,merge,pick,splat,wrap}=U,ChartProto=Chart.prototype,defaultXAxisOptions={lineWidth:0,tickLength:0,opposite:!0,type:"category"},defaultParallelOptions={parallelCoordinates:!1,parallelAxes:{lineWidth:1,title:{text:"",reserveSpace:!1},labels:{x:0,y:4,align:"center",reserveSpace:!1},offset:0}};function addFormattedValue(t){let e=this.series&&this.series.chart,a=t.apply(this,Array.prototype.slice.call(arguments,1)),i,s,r,o;return e&&e.hasParallelCoordinates&&!defined(a.formattedValue)&&(s=(o=e.yAxis[this.x]).options,r=pick(s.tooltipValueFormat,s.labels.format),i=r?format(r,extend(this,{value:this.y}),e):o.dateTime?e.time.dateFormat(e.time.resolveDTLFormat(s.dateTimeLabelFormats[o.tickPositions.info.unitName]).main,this.y):s.categories?s.categories[this.y]:this.y,a.formattedValue=a.point.formattedValue=i),a}setOptions({chart:defaultParallelOptions}),addEvent(Chart,"init",function(t){const e=t.args[0],a=splat(e.yAxis||{}),i=[];let s=a.length;if(this.hasParallelCoordinates=e.chart&&e.chart.parallelCoordinates,this.hasParallelCoordinates){for(this.setParallelInfo(e);s<=this.parallelInfo.counter;s++)i.push({});e.legend||(e.legend={}),void 0===e.legend.enabled&&(e.legend.enabled=!1),merge(!0,e,{boost:{seriesThreshold:Number.MAX_VALUE},plotOptions:{series:{boostThreshold:Number.MAX_VALUE}}}),e.yAxis=a.concat(i),e.xAxis=merge(defaultXAxisOptions,splat(e.xAxis||{})[0])}}),addEvent(Chart,"update",function(t){t=t.options;t.chart&&(defined(t.chart.parallelCoordinates)&&(this.hasParallelCoordinates=t.chart.parallelCoordinates),this.options.chart.parallelAxes=merge(this.options.chart.parallelAxes,t.chart.parallelAxes)),this.hasParallelCoordinates&&(t.series&&this.setParallelInfo(t),this.yAxis.forEach(function(t){t.update({},!1)}))}),extend(ChartProto,{setParallelInfo:function(t){const e=this,a=t.series;e.parallelInfo={counter:0},a.forEach(function(t){t.data&&(e.parallelInfo.counter=Math.max(e.parallelInfo.counter,t.data.length-1))})}}),addEvent(Series,"bindAxes",function(t){if(this.chart.hasParallelCoordinates){const e=this;this.chart.axes.forEach(function(t){e.insert(t.series),t.isDirty=!0}),e.xAxis=this.chart.xAxis[0],e.yAxis=this.chart.yAxis[0],t.preventDefault()}}),addEvent(Series,"afterTranslate",function(){let t=this.chart,e=this.points,a=e&&e.length,i=Number.MAX_VALUE,s,r,o;if(this.chart.hasParallelCoordinates){for(o=0;o<a;o++)r=e[o],defined(r.y)?(t.polar?r.plotX=t.yAxis[o].angleRad||0:t.inverted?r.plotX=t.plotHeight-t.yAxis[o].top+t.plotTop:r.plotX=t.yAxis[o].left-t.plotLeft,r.clientX=r.plotX,r.plotY=t.yAxis[o].translate(r.y,!1,!0,void 0,!0),isNumber(r.high)&&(r.plotHigh=t.yAxis[o].translate(r.high,!1,!0,void 0,!0)),void 0!==s&&(i=Math.min(i,Math.abs(r.plotX-s))),s=r.plotX,r.isInside=t.isInsidePlot(r.plotX,r.plotY,{inverted:t.inverted})):r.isNull=!0;this.closestPointRangePx=i}},{order:1}),addEvent(Series,"destroy",function(){this.chart.hasParallelCoordinates&&(this.chart.axes||[]).forEach(function(t){t&&t.series&&(erase(t.series,this),t.isDirty=t.forceRedraw=!0)},this)}),["line","spline"].forEach(function(t){wrap(H.seriesTypes[t].prototype.pointClass.prototype,"getLabelConfig",addFormattedValue)});class ParallelAxisAdditions{constructor(t){this.axis=t}setPosition(t,e){const a=this.axis,i=a.chart,s=((this.position||0)+.5)/(i.parallelInfo.counter+1);i.polar?e.angle=360*s:(e[t[0]]=100*s+"%",a[t[1]]=e[t[1]]=0,a[t[2]]=e[t[2]]=null,a[t[3]]=e[t[3]]=null)}}var ParallelAxis;!function(){function e(t){const e=this,a=e.chart,i=e.parallelCoordinates;let s=["left","width","height","top"];var r;a.hasParallelCoordinates&&(a.inverted&&(s=s.reverse()),e.isXAxis?e.options=merge(e.options,defaultXAxisOptions,t.userOptions):(r=a.yAxis.indexOf(e),e.options=merge(e.options,e.chart.options.chart.parallelAxes,t.userOptions),i.position=pick(i.position,0<=r?r:a.yAxis.length),i.setPosition(s,e.options)))}function a(t){var a=this,e=a.chart,i=a.parallelCoordinates;if(i&&e&&e.hasParallelCoordinates&&!a.isXAxis){const s=i.position;let e=[];a.series.forEach(function(t){t.yData&&t.visible&&isNumber(s)&&(t=t.yData[s],e.push.apply(e,splat(t)))}),e=e.filter(isNumber),a.dataMin=arrayMin(e),a.dataMax=arrayMax(e),t.preventDefault()}}function i(){this.parallelCoordinates||(this.parallelCoordinates=new ParallelAxisAdditions(this))}(ParallelAxis||(ParallelAxis={})).compose=function(t){t.keepProps.push("parallel"),addEvent(t,"init",i),addEvent(t,"afterSetOptions",e),addEvent(t,"getSeriesExtremes",a)}}(),ParallelAxis.compose(Axis);export default ParallelAxis;