!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){"use strict";t=t?t._modules:{};function e(t,e,a,o){t.hasOwnProperty(e)||(t[e]=o.apply(null,a),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:e,module:t[e]}})))}e(t,"Extensions/MarkerClusters.js",[t["Core/Animation/AnimationUtilities.js"],t["Core/Chart/Chart.js"],t["Core/Defaults.js"],t["Core/Series/Point.js"],t["Core/Series/Series.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Renderer/SVG/SVGRenderer.js"],t["Core/Utilities.js"],t["Core/Axis/Axis.js"]],function(t,e,a,o,i,r,n,s,l){const I=t["animObject"],p=a["defaultOptions"];t=r.seriesTypes;const u=n["prototype"]["symbols"],{addEvent:D,defined:v,error:b,isArray:A,isFunction:z,isObject:X,isNumber:E,merge:Y,objectEach:P,relativeLength:w,syncTimeout:k}=s,d=t.scatter,T=i.prototype.generatePoints;let c=[],f=0;const O={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},V=((p.plotOptions||{}).series=Y((p.plotOptions||{}).series,{cluster:O,tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}),(t,e)=>{const{chart:a,xAxis:o,yAxis:i}=t;return a.mapView?a.mapView.pixelsToProjectedUnits(e):{x:o?o.toValue(e.x):0,y:i?i.toValue(e.y):0}}),j=(t,e)=>{const{chart:a,xAxis:o,yAxis:i}=t;return a.mapView?a.mapView.projectedUnitsToPixels(e):{x:o?o.toPixels(e.x):0,y:i?i.toPixels(e.y):0}};function G(t){let e=t.length,a=0,o=0,i;for(i=0;i<e;i++)a+=t[i].x,o+=t[i].y;return{x:a/e,y:o/e}}function h(t,e){const a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function m(t,e,a){t.attr({opacity:e}).animate({opacity:1},a)}function M(t,e,a,o,i){t.point&&(o&&t.point.graphic&&(t.point.graphic.show(),m(t.point.graphic,e,a)),i&&t.point.dataLabel&&(t.point.dataLabel.show(),m(t.point.dataLabel,e,a)))}function S(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function L(t,e,a,o){M(t,o,a,!0,!0),e.forEach(function(t){t.point&&t.point.destroy&&t.point.destroy()})}function R(){return Math.random().toString(36).substring(2,7)+"-"+f++}u.cluster=function(t,e,a,o){const i=a/2,r=o/2,n=u.arc(t+i,e+r,i-4,r-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),s=u.arc(t+i,e+r,i-3,r-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:i-2,open:!1}),l=u.arc(t+i,e+r,i-1,r-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:i,open:!1});return l.concat(s,n)},d.prototype.animateClusterPoint=function(t){const e=this.chart,a=e.mapView,o=this.options.cluster,i=I((o||{}).animation),r=i.duration||500,n=(this.markerClusterInfo||{}).pointsState,s=(n||{}).newState,l=(n||{}).oldState,p=[];let u,d,c,h,m,f,g,x=!1,y=!1;var C;l&&s&&(c=s[t.stateId],C=j(this,c),f=C.x-(a?0:e.plotLeft),g=C.y-(a?0:e.plotTop),1===c.parentsId.length?(u=(s||{})[t.stateId].parentsId[0],d=l[u],c.point&&c.point.graphic&&d&&d.point&&d.point.plotX&&d.point.plotY&&d.point.plotX!==c.point.plotX&&d.point.plotY!==c.point.plotY&&(h=c.point.graphic.getBBox(),m=c.point.graphic&&c.point.graphic.isImg?0:h.width/2,c.point.graphic.attr({x:d.point.plotX-m,y:d.point.plotY-m}),c.point.graphic.animate({x:f-(c.point.graphic.radius||0),y:g-(c.point.graphic.radius||0)},i,function(){y=!0,d.point&&d.point.destroy&&d.point.destroy()}),c.point.dataLabel&&c.point.dataLabel.alignAttr&&d.point.dataLabel&&d.point.dataLabel.alignAttr&&(c.point.dataLabel.attr({x:d.point.dataLabel.alignAttr.x,y:d.point.dataLabel.alignAttr.y}),c.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y},i)))):0===c.parentsId.length?(S(c,!0,!0),k(function(){M(c,.1,i,!0,!0)},r/2)):(S(c,!0,!0),c.parentsId.forEach(function(t){l&&l[t]&&(d=l[t],p.push(d),d.point&&d.point.graphic&&(x=!0,d.point.graphic.show(),d.point.graphic.animate({x:f-(d.point.graphic.radius||0),y:g-(d.point.graphic.radius||0),opacity:.4},i,function(){y=!0,L(c,p,i,.7)}),d.point.dataLabel&&-9999!==d.point.dataLabel.y&&c.point&&c.point.dataLabel&&c.point.dataLabel.alignAttr&&(d.point.dataLabel.show(),d.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y,opacity:.4},i))))}),k(function(){y||L(c,p,i,.85)},r),x||k(function(){L(c,p,i,.1)},r/2)))},d.prototype.getGridOffset=function(){let t=this,e=t.chart,a=t.xAxis,o=t.yAxis,i=0,r=0;return i=a&&t.dataMinX&&t.dataMaxX?a.reversed?a.toPixels(t.dataMaxX):a.toPixels(t.dataMinX):e.plotLeft,r=o&&t.dataMinY&&t.dataMaxY?o.reversed?o.toPixels(t.dataMinY):o.toPixels(t.dataMaxY):e.plotTop,{plotLeft:i,plotTop:r}},d.prototype.getScaledGridSize=function(t){const e=this,a=e.xAxis,o=this.chart.mapView,i=t.processedGridSize||O.layoutAlgorithm.gridSize;let r=!0,n=1,s=1;e.gridValueSize||(o?e.gridValueSize=i/o.getScale():e.gridValueSize=Math.abs(a.toValue(i)-a.toValue(0)));for(var l=+(i/(o?e.gridValueSize*o.getScale():a.toPixels(e.gridValueSize)-a.toPixels(0))).toFixed(14);r&&1!=l;){var p=Math.pow(2,n);.75<l&&l<1.25?r=!1:1/p<=l&&l<1/p*2?(r=!1,s=p):l<=p&&p/2<l&&(r=!1,s=1/p),n++}return i/s/l},d.prototype.getRealExtremes=function(){var t=this.chart,e=t.mapView?0:t.plotLeft,a=t.mapView?0:t.plotTop,a=V(this,{x:e,y:a}),e=V(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=a.x,o=e.x,a=a.y,e=e.y;return{minX:Math.min(t,o),maxX:Math.max(t,o),minY:Math.min(a,e),maxY:Math.max(a,e)}},d.prototype.onDrillToCluster=function(t){const e=t.point||t.target;e.firePointEvent("drillToCluster",t,function(t){const e=t.point||t.target,a=e.series,o=e.series.xAxis,i=e.series.yAxis,r=e.series.chart,n=r.mapView,s=a.options.cluster,l=(s||{}).drillToCluster;var p,u,d,c,h,m,f;l&&e.clusteredData&&(m=e.clusteredData.map(t=>t.x).sort((t,e)=>t-e),u=e.clusteredData.map(t=>t.y).sort((t,e)=>t-e),h=m[0],m=m[m.length-1],p=u[0],u=u[u.length-1],f=Math.abs(.1*(m-h)),d=Math.abs(.1*(u-p)),c=Math.min(h,m)-f,h=Math.max(h,m)+f,m=Math.min(p,u)-d,f=Math.max(p,u)+d,n?n.fitToBounds({x1:c,x2:h,y1:m,y2:f}):o&&i&&(r.pointer.zoomX=!0,r.pointer.zoomY=!0,r.zoom({originalEvent:t,xAxis:[{axis:o,min:c,max:h}],yAxis:[{axis:i,min:m,max:f}]})))})},d.prototype.getClusterDistancesFromPoint=function(e,a,o){const i=[];for(let t=0;t<e.length;t++){var r=j(this,{x:a,y:o}),n=j(this,{x:e[t].posX,y:e[t].posY}),r=Math.sqrt(Math.pow(r.x-n.x,2)+Math.pow(r.y-n.y,2));i.push({clusterIndex:t,distance:r})}return i.sort((t,e)=>t.distance-e.distance)},d.prototype.getPointsState=function(t,e,a){let o=e?h(e,a):[],i=h(t,a),r={},n,s,l;for(c=[],t.clusters.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),l=0;l<i.length;l++)n=i[l],s=o[l],n&&s&&n.parentStateId&&s.parentStateId&&r[n.parentStateId]&&-1===r[n.parentStateId].parentsId.indexOf(s.parentStateId)&&(r[n.parentStateId].parentsId.push(s.parentStateId),-1===c.indexOf(s.parentStateId)&&c.push(s.parentStateId));return r},d.prototype.markerClusterAlgorithms={grid:function(t,e,a,o){const i={},r=this.getGridOffset();let n,s,l,p,u;var d=this.getScaledGridSize(o);for(u=0;u<t.length;u++){var c=j(this,{x:t[u],y:e[u]});n=c.x-r.plotLeft,s=c.y-r.plotTop,l=Math.floor(n/d),p=Math.floor(s/d)+"-"+l,i[p]||(i[p]=[]),i[p].push({dataIndex:a[u],x:t[u],y:e[u]})}return i},kmeans:function(t,e,a,o){let i=this,r=[],n=[],s={},l=o.processedDistance||O.layoutAlgorithm.distance,p=o.iterations,u=0,d=!0,c,h,m,f=[],g,x,y,C;for(x in o.processedGridSize=o.processedDistance,g=i.markerClusterAlgorithms?i.markerClusterAlgorithms.grid.call(i,t,e,a,o):{})1<g[x].length&&(m=G(g[x]),r.push({posX:m.x,posY:m.y,oldX:0,oldY:0,startPointsLen:g[x].length,points:[]}));for(;d;){for(r.map(t=>(t.points.length=0,t)),n.length=0,y=0;y<t.length;y++)c=t[y],h=e[y],((f=i.getClusterDistancesFromPoint(r,c,h)).length&&f[0].distance<l?r[f[0].clusterIndex].points:n).push({x:c,y:h,dataIndex:a[y]});for(C=0;C<r.length;C++)1===r[C].points.length&&(f=i.getClusterDistancesFromPoint(r,r[C].points[0].x,r[C].points[0].y))[1].distance<l&&(r[f[1].clusterIndex].points.push(r[C].points[0]),r[f[0].clusterIndex].points.length=0);for(d=!1,C=0;C<r.length;C++)m=G(r[C].points),r[C].oldX=r[C].posX,r[C].oldY=r[C].posY,r[C].posX=m.x,r[C].posY=m.y,(r[C].posX>r[C].oldX+1||r[C].posX<r[C].oldX-1||r[C].posY>r[C].oldY+1||r[C].posY<r[C].oldY-1)&&(d=!0);p&&(d=u<p-1),u++}return r.forEach(function(t,e){s["cluster"+e]=t.points}),n.forEach(function(t,e){s["noise"+e]=[t]}),s},optimizedKmeans:function(t,e,a,o){let i=this,r=o.processedDistance||O.layoutAlgorithm.gridSize,n={},s=i.getRealExtremes(),l=(i.options.cluster||{}).marker,p,u,d;return!i.markerClusterInfo||i.initMaxX&&i.initMaxX<s.maxX||i.initMinX&&i.initMinX>s.minX||i.initMaxY&&i.initMaxY<s.maxY||i.initMinY&&i.initMinY>s.minY?(i.initMaxX=s.maxX,i.initMinX=s.minX,i.initMaxY=s.maxY,i.initMinY=s.minY,n=i.markerClusterAlgorithms?i.markerClusterAlgorithms.kmeans.call(i,t,e,a,o):{},i.baseClusters=null):(i.baseClusters||(i.baseClusters={clusters:i.markerClusterInfo.clusters,noise:i.markerClusterInfo.noise}),i.baseClusters.clusters.forEach(function(o){o.pointsOutside=[],o.pointsInside=[],o.data.forEach(function(t){var e=j(i,t),a=j(i,o);u=Math.sqrt(Math.pow(e.x-a.x,2)+Math.pow(e.y-a.y,2)),d=(o.clusterZone&&o.clusterZone.marker&&o.clusterZone.marker.radius?o.clusterZone.marker:l&&l.radius?l:O.marker).radius,p=0<=r-d?r-d:d,u>d+p&&v(o.pointsOutside)?o.pointsOutside.push(t):v(o.pointsInside)&&o.pointsInside.push(t)}),o.pointsInside.length&&(n[o.id]=o.pointsInside),o.pointsOutside.forEach(function(t,e){n[o.id+"_noise"+e]=[t]})}),i.baseClusters.noise.forEach(function(t){n[t.id]=t.data})),n}},d.prototype.preventClusterCollisions=function(t){let a=this,[o,i]=t.key.split("-").map(parseFloat),r=t.gridSize,n=t.groupedData,s=t.defaultRadius,l=t.clusterRadius,p=i*r,u=o*r,e=j(a,t),d=e.x,c=e.y,h=[],m,f=0,g=(a.options.cluster||{}).marker,x=(a.options.cluster||{}).zones,y=a.getGridOffset(),C,I,k,M,S,b,A,X,Y,L,D,z,E;for(d-=y.plotLeft,c-=y.plotTop,A=1;A<5;A++)for(k=A%2?-1:1,M=A<3?-1:1,S=Math.floor((d+k*l)/r),E=[(b=Math.floor((c+M*l)/r))+"-"+S,b+"-"+i,o+"-"+S],X=0;X<E.length;X++)-1===h.indexOf(E[X])&&E[X]!==t.key&&h.push(E[X]);h.forEach(function(t){if(n[t]){n[t].posX||(D=G(n[t]),n[t].posX=D.x,n[t].posY=D.y);var e=j(a,{x:n[t].posX||0,y:n[t].posY||0});if(C=e.x-y.plotLeft,I=e.y-y.plotTop,[L,Y]=t.split("-").map(parseFloat),x)for(m=n[t].length,A=0;A<x.length;A++)m>=x[A].from&&m<=x[A].to&&(f=v((x[A].marker||{}).radius)?x[A].marker.radius||0:(g&&g.radius?g:O.marker).radius);1<n[t].length&&0===f&&g&&g.radius?f=g.radius:1===n[t].length&&(f=s),z=l+f,f=0,Y!==i&&Math.abs(d-C)<z&&(d=Y-i<0?p+l:p+r-l),L!==o&&Math.abs(c-I)<z&&(c=L-o<0?u+l:u+r-l)}});var P=V(a,{x:d+y.plotLeft,y:c+y.plotTop});return n[t.key].posX=P.x,n[t.key].posY=P.y,P},d.prototype.isValidGroupedDataObject=function(t){let e=!1,a;return!!X(t)&&(P(t,function(t){if(e=!0,A(t)&&t.length){for(a=0;a<t.length;a++)if(!X(t[a])||!t[a].x||!t[a].y)return void(e=!1)}else e=!1}),e)},d.prototype.getClusteredData=function(t,e){let a=this,o=[],i=[],r=[],n=[],s=[],l=0,p=Math.max(2,e.minimumClusterSize||2),u,d,c,h,m,f,g,x,y,C,I,k,M,S;if(z(e.layoutAlgorithm.type)&&!a.isValidGroupedDataObject(t))return b("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,a.chart),!1;for(S in t)if(t[S].length>=p){if(c=t[S],u=R(),m=c.length,e.zones)for(M=0;M<e.zones.length;M++)m>=e.zones[M].from&&m<=e.zones[M].to&&((I=e.zones[M]).zoneIndex=M,C=e.zones[M].marker,k=e.zones[M].className);for(y=G(c),g="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:y.x,y:y.y}:(f=a.options.marker||{},a.preventClusterCollisions({x:y.x,y:y.y,key:S,groupedData:t,gridSize:a.getScaledGridSize(e.layoutAlgorithm),defaultRadius:f.radius||3+(f.lineWidth||0),clusterRadius:C&&C.radius?C.radius:(e.marker||{}).radius||O.marker.radius})),M=0;M<m;M++)c[M].parentStateId=u;if(r.push({x:g.x,y:g.y,id:S,stateId:u,index:l,data:c,clusterZone:I,clusterZoneClassName:k}),o.push(g.x),i.push(g.y),s.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:Y(e.marker,{states:e.states},C||{})}}),a.options.data&&a.options.data.length)for(M=0;M<m;M++)X(a.options.data[c[M].dataIndex])&&(c[M].options=a.options.data[c[M].dataIndex]);l++,C=null}else for(M=0;M<t[S].length;M++)d=t[S][M],u=R(),x=null,h=((a.options||{}).data||[])[d.dataIndex],o.push(d.x),i.push(d.y),d.parentStateId=u,n.push({x:d.x,y:d.y,id:S,stateId:u,index:l,data:t[S]}),x=h&&"object"==typeof h&&!A(h)?Y(h,{x:d.x,y:d.y}):{userOptions:h,x:d.x,y:d.y},s.push({options:x}),l++;return{clusters:r,noise:n,groupedXData:o,groupedYData:i,groupMap:s}},d.prototype.destroyClusteredData=function(){const t=this.markerClusterSeriesData;(t||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null},d.prototype.hideClusteredData=function(){const t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=c.map(t=>(e[t].point||{}).id||"");(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})},d.prototype.generatePoints=function(){const a=this,t=a.chart,e=t.mapView,o=a.xData,i=a.yData,r=a.options.cluster,n=a.getRealExtremes(),s=[],l=[],p=[];let u,d,c,h,m,f,g,x,y,C,I,k,M,S,b,A,X;if(e&&a.is("mappoint")&&o&&i&&(a.options.data||[]).forEach((t,e)=>{t=a.projectPoint(t);t&&(o[e]=t.x,i[e]=t.y)}),r&&r.enabled&&o&&o.length&&i&&i.length&&!t.polar){I=r.layoutAlgorithm.type,(b=r.layoutAlgorithm).processedGridSize=w(b.gridSize||O.layoutAlgorithm.gridSize,t.plotWidth),b.processedDistance=w(b.distance||O.layoutAlgorithm.distance,t.plotWidth),h=b.kmeansThreshold||O.layoutAlgorithm.kmeansThreshold;var Y=b.processedGridSize/2,L=V(a,{x:0,y:0}),Y=V(a,{x:Y,y:Y});for(m=Math.abs(L.x-Y.x),f=Math.abs(L.y-Y.y),X=0;X<o.length;X++)a.dataMaxX||(v(x)&&v(g)&&v(C)&&v(y)?E(i[X])&&E(C)&&E(y)&&(x=Math.max(o[X],x),g=Math.min(o[X],g),C=Math.max(i[X]||C,C),y=Math.min(i[X]||y,y)):(x=g=o[X],C=y=i[X])),o[X]>=n.minX-m&&o[X]<=n.maxX+m&&(i[X]||n.minY)>=n.minY-f&&(i[X]||n.maxY)<=n.maxY+f&&(s.push(o[X]),l.push(i[X]),p.push(X));v(x)&&v(g)&&E(C)&&E(y)&&(a.dataMaxX=x,a.dataMinX=g,a.dataMaxY=C,a.dataMinY=y),M=(S=(k=z(I)?I:a.markerClusterAlgorithms?I&&a.markerClusterAlgorithms[I]?a.markerClusterAlgorithms[I]:s.length<h?a.markerClusterAlgorithms.kmeans:a.markerClusterAlgorithms.grid:function(){return!1}).call(this,s,l,p,b))&&a.getClusteredData(S,r),u=r.animation&&a.markerClusterInfo&&a.markerClusterInfo.pointsState&&a.markerClusterInfo.pointsState.oldState?((L=a.markerClusterInfo.pointsState.oldState)&&P(L,function(t){t.point&&t.point.destroy&&t.point.destroy()}),a.markerClusterInfo.pointsState.newState):{},d=o.length,c=a.markerClusterInfo,M&&(a.processedXData=M.groupedXData,a.processedYData=M.groupedYData,a.hasGroupedData=!0,a.markerClusterInfo=M,a.groupMap=M.groupMap),T.apply(this),M&&a.markerClusterInfo&&((a.markerClusterInfo.clusters||[]).forEach(function(t){(A=a.points[t.index]).isCluster=!0,A.clusteredData=t.data,A.clusterPointsAmount=t.data.length,t.point=A,D(A,"click",a.onDrillToCluster)}),(a.markerClusterInfo.noise||[]).forEach(function(t){t.point=a.points[t.index]}),r.animation&&a.markerClusterInfo&&(a.markerClusterInfo.pointsState={oldState:u,newState:a.getPointsState(M,c,d)}),r.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else T.apply(this)},D(e,"render",function(){(this.series||[]).forEach(function(e){var t,a;e.markerClusterInfo&&(t=e.options.cluster,a=((e.markerClusterInfo||{}).pointsState||{}).oldState,(t||{}).animation&&e.markerClusterInfo&&0===e.chart.pointer.pinchDown.length&&"pan"!==((e.xAxis||{}).eventArgs||{}).trigger&&a&&Object.keys(a).length&&(e.markerClusterInfo.clusters.forEach(function(t){e.animateClusterPoint(t)}),e.markerClusterInfo.noise.forEach(function(t){e.animateClusterPoint(t)})))})}),D(o,"update",function(){if(this.dataGroup)return b("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}),D(i,"destroy",d.prototype.destroyClusteredData),D(i,"afterRender",function(){const e=(this.options.cluster||{}).drillToCluster;this.markerClusterInfo&&this.markerClusterInfo.clusters&&this.markerClusterInfo.clusters.forEach(function(t){t.point&&t.point.graphic&&(t.point.graphic.addClass("highcharts-cluster-point"),e&&t.point&&(t.point.graphic.css({cursor:"pointer"}),t.point.dataLabel&&t.point.dataLabel.css({cursor:"pointer"})),v(t.clusterZone)&&t.point.graphic.addClass(t.clusterZoneClassName||"highcharts-cluster-zone-"+t.clusterZone.zoneIndex))})}),D(o,"drillToCluster",function(t){const e=t.point||t.target,a=e.series,o=a.options.cluster,i=((o||{}).events||{}).drillToCluster;z(i)&&i.call(this,t)}),D(l,"setExtremes",function(){let t=this.chart,e=0,a;t.series.forEach(function(t){t.markerClusterInfo&&(a=I((t.options.cluster||{}).animation),e=a.duration||0)}),k(function(){t.tooltip&&t.tooltip.destroy()},e)})}),e(t,"masters/modules/marker-clusters.src.js",[],function(){})});